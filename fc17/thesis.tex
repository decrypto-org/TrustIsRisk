\documentclass[11pt]{llncs}
\usepackage{graphicx}
\usepackage[linesnumbered,ruled,noend]{algorithm2e}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{listings}

\lstset{frame=tb,
  showstringspaces=false,
  columns=flexible,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  escapeinside={(*@}{@*)},
  frame=n
}
\lstdefinestyle{numbers}{numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt}
\let\origthelstnumber\thelstnumber
\makeatletter
\newcommand*\Suppressnumber{%
  \lst@AddToHook{OnNewLine}{%
    \let\thelstnumber\relax%
     \advance\c@lstnumber-\@ne\relax%
    }%
}

\newcommand*\Reactivatenumber{%
  \lst@AddToHook{OnNewLine}{%
   \let\thelstnumber\origthelstnumber%
   \advance\c@lstnumber\@ne\relax}%
}

\bibliographystyle{splncs}
\usepackage{color,hyperref}
\definecolor{darkblue}{rgb}{0.0,0.0,0.3}
\hypersetup{colorlinks,breaklinks,
    linkcolor=darkblue,urlcolor=darkblue,
    anchorcolor=darkblue,citecolor=darkblue}

\begin{document}

     \begin{definition}[Trust Reduction] \ \\ 
        Let $A, B \in \mathcal{V}$ and $x_i$ flow to $N^{+}(A)_i$ resulting from $maxFlow(A,B), u_i = 
        DTr_{A \rightarrow N^{+}(A)_i,j-1}, u_i' = DTr_{A \rightarrow N^{+}(A)_i,j},$ \\ $i \in [|N^{+}(A)|], 
        j \in \mathbb{N}$. 
        \begin{enumerate} 
           \item The Trust Reduction on neighbour $i, \delta_i$ is defined as $\delta_i = u_i - u_i'$. 
           \item The Flow Reduction on neigbour $i, \Delta_i$ is defined as $\Delta_i = x_i - u_i'$. 
        \end{enumerate} 
        We will also use the standard notation for 1-norm and $\infty$-norm, that is: 
        \begin{enumerate} 
           \item $||\delta_i||_1 = \sum\limits_{i \in N^{+}(A)}\delta_i$ 
           \item $||\delta_i||_\infty = \max\limits_{i \in N^{+}(A)}\delta_i$. 
        \end{enumerate} 
     \end{definition} 
     \begin{definition}[Restricted Flow] \ \\ 
        Let $A, B \in \mathcal{V}, i \in [|N^{+}(A)|]$. 
        \begin{enumerate} 
           \item Let $F_{A_i \rightarrow B}$ be the flow from $A$ to $N^{+}(A)_i$ as calculated by the $maxFlow(A,B)$ 
              ($x_i'$) when $u_i' = u_i,$ \\ $u_k' = 0 \:\forall k \in [|N^{+}(A)|] \wedge k \neq i$. 
           \item Let $S \subset N^{+}(A)$. Let $F_{A_S \rightarrow B}$ be the sum of flows from $A$ to $S$ as 
              calculated by the $maxFlow(A,B)$ ($\sum\limits_{i=1}^{|S|}x_i'$) when $u_C' = u_C \: \forall C \in S, 
              u_D' = 0 \: \forall D \in N^{+}(A) \setminus S$. 
        \end{enumerate} 
     \end{definition} 

    \begin{theorem}[Saturation theorem] \ \\  
       \label{saturation} 
       Let $s$ source, $n = |N^{+}(s)|, x_i, i \in [n]$, flows to $s$'s neighbours as calculated by the 
       maxFlow algorithm, $u_i'$ new direct trusts to the $n$ neighbours and $x_i'$ new flows to the neighbours 
       as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. It holds that 
       $\forall i \in [n], u_i' \leq x_i \Rightarrow x_i' = u_i'$. 
    \end{theorem} 
    \begin{proof} \  
       $\forall i \in [n], x_i' > u_i'$ is impossible because a flow cannot be higher than its 
       corresponding capacity. Thus $\forall i \in [n], x_i' \leq u_i'$. (1) \\ 
       In the initial configuration of $u_i$ and according to the flow problem setting, a combination of flows 
       $y_i$ such that $\forall i \in [n], y_i = u_i'$ is a valid, albeit not necessarily maximum, 
       configuration with a flow $\sum\limits_{i=1}^{n}y_i$. Suppose that $\exists k \in [n] : x_k' 
       < u_k'$ as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. Then for the new 
       maxFlow $F'$ it holds that $F' = \sum\limits_{i=1}^{n}x_i' < \sum\limits_{i=1}^{n}y_i$ since $x_k' < y_k$ 
       and (1) which is impossible because the configuration $\forall i \in [n], x_i' = y_i$ is valid since  
       $\forall i \in [n], y_i = u_i'$ and also has a higher flow, thus the maxFlow algorithm will 
       prefer the configuration with the higher flow. Thus we deduce that $\forall i \in [n], x_i' = u_i'$. \qed 
    \end{proof}

    \begin{theorem}[Trust transfer theorem (flow terminology)] \ \\
       \label{trusttransfer}
       Let $s$ source, $t$ sink, $n = N^{+}(s)$ \\
       $X = \{x_1, \dots, x_n\}$ outgoing flows from $s$, \\
       $U = \{u_1, \dots, u_n\}$ outgoing capacities from $s$, \\
       $V$ the value to be transferred. \\
       Nodes apart from $s$, $t$ follow the conservative strategy. \\
       Obviously $maxFlow = F = \sum\limits_{i=1}^{n}{x_i}$.
       {\em \begin{lstlisting}
            /                      ....                     \
           / x_s1/u_s1                         x_1t/u_1t     \
          /                                                   \
         /                                                     \
        / x_s2/u_s2                               x_2t/u_2t     \
       s-------------              ....          ------------t
        \      .                                           .    /
         \     .                                           .   /
          \    .                                           .  /
           \ x_sn/u_sn             ....        x_mt/u_mt     /
            \                                               /
       \end{lstlisting}}
       We create a new graph where
       \begin{enumerate}
         \item  $\sum\limits_{i=1}^{n}{u_i'} = F - V$
         \item $\forall i \in [n] \: u_i' \leq x_i$
       \end{enumerate}

       It holds that $maxFlow' = F' = F - V$.
    \end{theorem}
    \begin{proof} \
        From theorem \ref{saturation} we can see that $x_i' = u_i'$. It holds that $F' = \sum\limits_{i=1}^nx_i' =
        \sum\limits_{i=1}^nu_i' = F - V$. \qed
    \end{proof}

%    \begin{corollary}[Requirement for $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V$, $u_{s, i}' \leq x_{s, i}$] \ \\
%       In the setting of \ref{trusttransfer}, it is impossible to have $maxFlow' = F - V$ if
%       $\sum\limits_{i=1}^{n}{u_{s, i}'} > F - V \wedge \forall i \in [n],u_{s, i}' \leq x_{s, i}$.
%    \end{corollary}
%    \begin{proof}
%       Due to \ref{trusttransfer}, $maxFlow' = F - V$ if $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V
%       \wedge \forall i \in [n], u_{s, i}' \leq x_{s, i}$. If we create new capacities such that
%       $\forall i \in [n], u_{s,i}'' \leq x_{s,i}$, then obviously $maxFlow'' = \sum\limits_{i=1}^{n}{u_{s,i}''}$. If
%       additionally $\sum\limits_{i=1}^{n}{u_{s,i}''} > F - V$, then $maxFlow'' > F - V$.
%    \end{proof}

    \begin{lemma}[Flow limit lemma] \ \\
       \label{flowlimit}
       It is impossible for the outgoing flow $x_i$ from $A$ to an out neighbour of $A$ to be greater than
       $F_{A_i \rightarrow B}$. More formally, $x_i \leq F_{A_i \rightarrow B}$.
    \end{lemma}
    \begin{proof}
       Suppose a configuration where $\exists i : x_i > F_{A_i \rightarrow B}$. If we reduce the capacities $u_k, k \neq i$
       the flow that passes from $i$ in no case has to be reduced. Thus we can set $\forall k \neq i, u_k' = 0$ and $u_i' =
       u_i$. Then $\forall k \neq i,x_k' = 0, x_i' = x_i$ is a valid configuration and thus by definition $F_{A_i \rightarrow
       B} = x_i' = x_i > F_{A_i \rightarrow B}$, which is a contradiction. Thus $\forall i \in [|N^{+}(A)|], x_i \leq
       F_{A_i \rightarrow B}$. \qed
    \end{proof}

    \begin{theorem}[Trust-saving Theorem] \ \\
       \label{trustsave}
       A configuration $U' : u_i' = F_{A_i \rightarrow B}$ for some $i \in [|N^{+}(A)|]$ can yield the same $maxFlow$ with a
       configuration $U'' : u_i'' = u_i, \forall k \in [|N^{+}(A)|], k \neq i, u_k'' = u_k'$.
    \end{theorem}
    \begin{proof}
       We know that $x_i \leq F_{A_i \rightarrow B}$ (lemma \ref{flowlimit}), thus we can see that any increase in $u_i'$
       beyond $F_{A_i \rightarrow B}$ will not influence $x_i$ and subsequently will not incur any change on the rest of the
       flows. \qed
    \end{proof}

    \begin{theorem}[Invariable trust reduction with naive algorithms] \ \\
       \label{invariability}
       Let $A$ source, $n = |N^{+}(A)|$ and $u_i'$ new direct trusts. If $\forall i \in [n],u_i' \leq x_i$,
       Trust Reduction $||\delta_i||_1$ is independent of $x_i, u_i' \:\: \forall$ valid configurations of $x_i$
    \end{theorem}
    \begin{proof}
       Since $\forall i \in [n],u_i' \leq x_i$ it is (according to \ref{saturation}) $x_i' = u_i'$, thus
       $\delta_i = u_i - x_i'$. We know that $\sum\limits_{i=1}^{n}x_i' = F - V$, so we have $||\delta_i||_1 =
       \sum\limits_{i=1}^{n}\delta_i = \sum\limits_{i=1}^{n}(u_i - x_i') = \sum\limits_{i=1}^{n}u_i - F + V$ independent
       from $x_i', u_i'$ \qed
    \end{proof}

%    \begin{theorem}[Dependence impossibility theorem] \ \\
%       \label{independence}
%       ${\partial x_k \over \partial x_i} = 0$ with $x_i$ the flow from MaxFlow $\Rightarrow
%         \forall x_i' \leq x_i, {\partial x_k \over \partial x_i} = 0$ ceteris paribus
%    \end{theorem}
%    \begin{proof}
%       TODO
%    \end{proof}

    Here we show three naive algorithms for calculating new direct trusts so as to maintain invariable risk when paying
    a trusted party. To prove the correctness of the algorithms, it suffices to prove that $\forall i \in [n] \:
    u_i' \leq x_i$ and that $\sum\limits_{i=1}^{n}u_i' = F - V$ where $F = \sum\limits_{i=1}^{n}x_i$. \\
    \begin{algorithm}[H]
       \label{fcfs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{First-come, first-served trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{fcfsfinit}\\
       \If{$F < V$ \label{fcfsifinputvalid}}{\Return $\bot$}
       $F_{cur} \gets F$ \label{fcfsfcurinit}\\
       \For{$i \gets 1$ to $n$ \label{fcfsforcapinit}}
          {$u_i' \gets x_i$} \label{fcfscapinit}
       $i \gets 1$ \label{fcfsiinit}\\
       \While{$F_{cur} > F - V$ \label{fcfsloop}}
          {$reduce \gets \min{(x_i, F_{cur} - F + V)}$ \\
           $F_{cur} \gets F_{cur} - reduce$ \\
           $u_i' \gets x_i - reduce$ \label{capmod}\\
           $i \gets i + 1$ \label{fcfsiinc}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{fcfsreturn}
    \end{algorithm}
    \begin{proof}[Proof of correctness for algorithm \ref{fcfs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          Let $i \in [n]$. In line~\ref{fcfscapinit} we can see that $u_i' = x_i$ and the only other occurence of $u_i'$
          is in line~\ref{capmod} where it is never increased $(reduce \geq 0)$, thus we see that, when returned,
          $u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          $F_{cur,0} = F$ \\
          If $F_{cur,i} \geq F - V$, then $F_{cur,i+1}$ does not exist because the \emph{while} loop breaks after calculating
          $F_{cur,i}$. \\
          Else $F_{cur,i+1} = F_{cur,i} - \min{(x_{i+1}, F_{cur,i} - F + V)}$. \\
          If for some $i, \min{(x_{i+1}, F_{cur,i} - F + V)} = F_{cur,i} - F + V$, then $F_{cur,i+1} = F - V$, so if
          $F_{cur,i+1}$ exists, then $\forall k < i, F_{cur,k} = F_{cur,k-1} - x_k \Rightarrow F_{cur,i} =
          F - \sum\limits_{k=1}^{i}x_k$ \\
          Furthermore, if $F_{cur,i+1} = F - V$ then $u_{i+1}' = x_{i+1} - F_{cur,i} + F - V =
          x_i - F + \sum\limits_{k=1}^{i-1}x_k + F - V = \sum\limits_{k=1}^{i}x_k - V$, $\forall k \leq i, u_k' = 0$
          and $\forall k > i+1, u_k' = x_k$. \\
          In total, we have $\sum\limits_{k=1}^{n}u_k' = \sum\limits_{k=1}^{i}x_k - V + \sum\limits_{k=i+1}^{n}x_k =
          \sum\limits_{k=1}^{n}x_k - V \Rightarrow \sum\limits_{k=1}^{n}u_k' = F - V$.
       \end{itemize}
       \qed
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{fcfs}] \ \\
       First we will prove that on line~\ref{fcfsreturn} $i \leq n+1$. Suppose that $i > n+1$ on line~\ref{fcfsreturn}. This
       means that $F_{cur,n}$ exists and $F_{cur,n} = F - \sum\limits_{i=1}^{n}x_i = 0 \leq F - V$ since, according to the
       condition on line~\ref{fcfsifinputvalid}, $F - V \geq 0$. This means however that the \emph{while} loop on
       line~\ref{fcfsloop} will break, thus $F_{cur,n+1}$ cannot exist and $i = n + 1$ on line~\ref{fcfsreturn}, which is a
       contradiction, thus $i \leq n+1$ on line~\ref{fcfsreturn}. Since $i$ is incremented by 1 on every iteration of the
       \emph{while} loop (line~\ref{fcfsiinc}), the complexity of the \emph{while} loop is $O(n)$ in the worst case. The
       complexity of lines~\ref{fcfsifinputvalid} -~\ref{fcfsfcurinit} and~\ref{fcfsiinit} is $O(1)$ and the complexity of
       lines~\ref{fcfsfinit},~\ref{fcfsforcapinit} -~\ref{fcfscapinit} and~\ref{fcfsreturn} is $O(n)$, thus the total
       complexity of algorithm \ref{fcfs} is $O(n)$. \qed
    \end{proof}

    \begin{algorithm}[H]
       \label{abs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Absolute equality trust transfer ($||\Delta_i||_\infty$ minimizer)}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}{\Return $\bot$}
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets x_i$ \label{abscapinit}}
       $reduce \gets {V \over n}$ \\
       $reduction \gets 0$ \\
       $empty \gets 0$ \\
       $i \gets 0$ \label{absiinit} \\
       \While{$reduction < V$ \label{absloop}}
          {\If{$u_i' > 0$ \label{absifcappositive}}{\If{$x_i < reduce$ \label{absifflowlessreduce}}
                {$empty \gets empty + 1$ \label{absemptyincrement} \\
                 \If{$empty < n$ \label{absifemptylessn}}
                    {$reduce \gets reduce + \frac{reduce - x_i}{n - empty}$ \label{absreducemodify}}
                 $reduction \gets reduction + u_i'$ \label{absreductionincrease} \\
                 $u_i' \gets 0$ \label{abscapzero} \\}
           \ElseIf{$x_i \geq reduce$}{$reduction \gets reduction + u_i' - (x_i - reduce)$ \label{absreductionmodify} \\
                 $u_i' \gets x_i - reduce$ \label{abscapreduce}}}
           $i \gets (i + 1) mod \:n$ \label{absiincrement}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{absreturn}
    \end{algorithm}
       \noindent
       We will start by showing some results useful for the following proofs. Let $j$ be the number of iterations of the
       \textbf{while} loop for the rest of the proofs for algorithm \ref{abs} (think of $i$ from line~\ref{absiincrement}
       without the $mod\:n$).\\
       First we will show that $empty \leq n$. $empty$ is only modified on line~\ref{absemptyincrement} where it is
       incremented by 1. This happens only when $u_i' > 0$ (line~\ref{absifcappositive}), which is assigned the value 0 on
       line~\ref{abscapzero}. We can see that the incrementation of $empty$ can happen at most $n$ times because
       $|U'| = n$. Since $empty_0 = 0$, $empty \leq n$ at all times of the execution. \\
       Next we will derive the recursive formulas for the various variables. \\
       $empty_0 = 0$ \\
       $empty_{j+1} = 
          \begin{cases}
             empty_j, & u_{(j+1)\:mod\:n}' = 0 \\
             empty_j+1, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             empty_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduce_0 = \frac{V}{n}$ \\
       $reduce_{j+1} =
          \begin{cases}
             reduce_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduce_j + \frac{reduce_j-x_{(j+1)\:mod\:n}}{n-empty_{j+1}}, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \:
                x_{(j+1) \:mod\:n} < reduce_j \\
             reduce_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduction_0 = 0$ \\
       $reduction_{j+1} =
          \begin{cases}
             reduction_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduction_j + u_{(j+1)\:mod\:n}', & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             reduction_j + u_{(j+1)\:mod\:n}' - x_{(j+1)\:mod\:n} + reduce_{j+1}, &
                u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\
       In the end, $r = reduce$ is such that $r = \frac{V - \sum\limits_{x \in S}x}{n - |S|}$ where
       $S = \{\text{flows } y \text{ from } s \text{ to } N^{+}(s) \text{ according to } maxFlow : y < r\}$. Also,
       $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}\max{(0,x_i - r)}$. TOPROVE
    \begin{proof}[Proof of correctness for algorithm \ref{abs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          On line~\ref{abscapinit}, $\forall i \in [n] \: u_i' = x_i$. Subsequently $u_i'$ is modified on
          line~\ref{abscapzero}, where it becomes equal to 0 and on line~\ref{abscapreduce}, where it is assigned
          $x_i - reduce$. It holds that $x_i - reduce \leq x_i$ because initially $reduce = \frac{V}{n} \geq 0$ and
          subsequently $reduce$ is modified only on line~\ref{absreducemodify} where it is increased ($n > empty$ because of
          line~\ref{absifemptylessn} and $reduce > x_i$ because of line~\ref{absifflowlessreduce}, thus
          $\frac{reduce - x_i}{n - empty} > 0$). We see that $\forall i \in [n], u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          The variable $reduction$ keeps track of the total reduction that has happened and breaks the \textbf{while} loop
          when $reduction \geq V$. We will first show that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times and
          then we will prove that $reduction = V$ at the end of the execution. Thus we will have proven that
          $\sum\limits_{i=1}^{n}u_i'= \sum\limits_{i=1}^{n}x_i - V = F - V$.
          \begin{itemize}
             \item On line~\ref{abscapinit}, $u_i' = x_i \Rightarrow \sum\limits_{i=1}^{n}(x_i- u_i') = 0$ and
             $reduction = 0$. \\
             On line~\ref{abscapzero}, $u_i'$ is reduced to 0 thus $\sum\limits_{i=1}^{n}(x_i- u_i')$ is increased by $u_i'$.
             Similarly, on line~\ref{absreductionincrease} $reduction$ is increased by $u_i'$, the same as the increase in
             $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             On line~\ref{abscapreduce}, $u_i'$ is reduced by $u_i' - x_i + reduce$ thus $\sum\limits_{i=1}^{n}(x_i- u_i')$
             is increased by $u_i' - x_i + reduce$. On line~\ref{absreductionmodify}, $reduction$ is increased by
             $u_i' - x_i + reduce$, which is equal to the increase in $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             We also have to note that neither $u_i'$ nor $reduction$ is modified in any other way from line~\ref{absloop}
             and on, thus we conclude that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times.
             \item Suppose that $reduction_j > V$ on the line~\ref{absreturn}. Since $reduction_j$ exists, $reduction_{j-1} < V$.
             If $x_{j \: mod \: n} < reduce_{j-1}$ then $reduction_j = reduction_{j-1} + u_{j \: mod \:n}'$.
             Since $reduction_j > V$, $u_{j \: mod \:n}' > V - reduction_{j-1}$. TOCOMPLETE\\

          \end{itemize}
       \end{itemize}
       \qed
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{abs}] \ \\
       In the worst case scenario, each time we iterate over all capacities only the last non-zero capacity will become zero
       and every non-zero capacity must be recalculated. This means that every $n$ steps exactly 1 capacity becomes zero
       and eventually all capacities (maybe except for one) become zero. Thus we need $O(n^2)$ steps in the worst case. \qed
    \end{proof}
    A variation of this algorithm using a Fibonacci heap with complexity $O(n)$ can be created, but that is part of
    further research.
    \begin{proof}[Proof that algorithm \ref{abs} minimizes the $||\Delta_i||_\infty$ norm] \ \\
       Suppose that $U'$ is the result of an execution of algorithm \ref{abs} that does not minimize the $||\Delta_i||_\infty$
       norm. Suppose that $W$ is a valid solution that minimizes the $||\Delta_i||_\infty$ norm. Let $\delta$ be the minimum
       value of this norm. There exists $i \in [n]$ such that $x_i - w_i = \delta$ and $u_i' < w_i$. Because both $U'$
       and $W$ are valid solutions ($\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}w_i = F - V$), there must exist a set
       $S \subset U'$ such that $\forall u_j' \in S, u_j' > w_j$ TOCOMPLETE.
    \end{proof}

    \begin{algorithm}[H]
       \label{prop}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Proportional equality trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{propfinit} \\
       \If{$F < V$ \label{propifinputvalid}}{\Return $\bot$ \label{propinputinvalid}}
       \For{$i \gets 1$ to $n$ \label{proploop}}
          {$u_i' \gets x_i - \frac{V}{F} x_i$ \label{propcapmodify}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{propreturn}
    \end{algorithm} \ \\
    \begin{proof}[Proof of correctness for algorithm \ref{prop}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          According to line~\ref{propcapmodify}, which is the only line where $u_i'$ is changed,
          $u_i' = x_i - \frac{V}{F}x_i \leq x_i$ since $x_i, V, F > 0$ and $V \leq F$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          With $F = \sum\limits_{i=1}^{n}x_i$, on line~\ref{propreturn} it holds that $\sum\limits_{i=1}^{n}u_i' =
          \sum\limits_{i=1}^{n}(x_i - \frac{V}{F}x_i) = \sum\limits_{i=1}^{n}x_i - \frac{V}{F}\sum\limits_{i=1}^{n}x_i =
          F - V$.
       \end{itemize}
       \qed
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{prop}] \ \\
       The complexity of lines~\ref{propfinit},~\ref{proploop} -~\ref{propcapmodify} and~\ref{propreturn} is $O(n)$ and the
       complexity of lines~\ref{propifinputvalid} -~\ref{propinputinvalid} is $O(1)$, thus the total complexity of algorithm
       \ref{prop} is $O(n)$. \qed
    \end{proof}

    Naive algorithms result in $u_i' \leq x_i$, thus according to \ref{invariability}, $||\delta_i||_1$ is invariable for
    any of the possible solutions $U'$, which is not necessarily the minimum (usually it will be the maximum). The following
    algorithms concentrate on minimizing two $\delta_i$ norms, $||\delta_i||_\infty$ and $||\delta_i||_1$. \\
    \begin{algorithm}[H]
       \label{dinf}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{BinSearch}{BinSearch}
       \Input{$X = \{x_i\}$ flows, $n = |N^{+}(s)|$, $V$ value, $\epsilon_1$, $\epsilon_2$}
       \Output{$u_i'$ capacities}
       \caption{$||\delta_i||_\infty$ minimizer}
       \If{$\epsilon_1 < 0 \vee \epsilon_2 < 0$ \label{dinfifepsilonsvalid}}
          {\Return $\bot$ \label{dinfepsilonsinvalid}}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{dinffinit} \\
       \If{$F < V$ \label{dinfifvvalid}}
          {\Return $\bot$ \label{dinfvinvalid}}
       $\delta_{max} \gets \max\limits_{i \in [n]}\{u_i\}$ \label{dinfdeltainit} \\
       $\delta^* \gets$ \BinSearch{0,$\delta_{max}$,F-V,n,X,$\epsilon_1$,$\epsilon_2$} \label{dinfcallbs} \\
       \For{$i \gets 1$ to $n$ \label{dinfforcap}}
          {$u_i' \gets \max{(u_i - \delta^*, 0)}$ \label{dinfcapset}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{dinfreturn}
    \end{algorithm}
    Since trust should be considered as a continuous unit and binary search dissects the possible interval for the solution
    on each recursive call, inclusion of the $\epsilon$-parameters in \texttt{BinSearch} is necessary for the algorithm to
    complete in a finite number of steps. \\
    \begin{algorithm}[H]
       \label{binsearch}
       \SetKwFunction{BinSearch}{BinSearch}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$bot$, $top$, $F'$, $n$, $X$, $\epsilon_1$, $\epsilon_2$}
       \Output{$\delta^*$}
       \caption*{\textbf{function} \texttt{BinSearch} }
       \If{$bot = top$ \label{bsifboteqtop}}{\Return $bot$ \label{bsretbot}}
       \Else{
          \For{$i \gets 1$ to $n$ \label{bsforcapset}}
              {$u_i' \gets \max{(0,u_i - \frac{top + bot}{2})}$ \label{bscapset}}
          \If{$maxFlow < F' - \epsilon_1$ \label{bsiflow}}
             {\Return \BinSearch{$bot$, $\frac{top+bot}{2}$,$F'$,$n$,$X$,$\epsilon_1$,$\epsilon_2$} \label{bsreclow}}
          \ElseIf{$maxFlow > F' + \epsilon_2$ \label{bsifhigh}}
             {\Return \BinSearch{$\frac{top+bot}{2}$, $top$,$F'$,$n$,$X$.$\epsilon_1$,$\epsilon_2$} \label{bsrechigh}}
          \Else
             {\Return $\frac{top + bot}{2}$\label{bsretmid}}
       }
    \end{algorithm}
    \begin{proof}[Proof that $maxFlow(\delta)$ is strictly decreasing for $\delta: maxflow(\delta) < F$] \ \\
       Let $maxFlow(\delta)$ be the $maxFlow$ with $\forall i \in [n], u_i' = max(0, u_i - \delta)$.
       We will prove that the function $maxFlow(\delta)$ is strictly decreasing for all $\delta \leq \max\limits_{i \in
       [n]}\{u_i\}$ such that $maxFlow(\delta) < F$. \\
       Supppose that $\exists \delta_1, \delta_2 : \delta_1 < \delta_2 \wedge maxFlow(\delta_1) \leq maxFlow(\delta_2) < F$.
       We will work with configurations of $x_{i,j}'$ such that $x_{i,j}' \leq x_i, j \in \{1,2\}$. \\
       Let $S_j = \{i \in N^{+}(s) : i \in MinCut_j\}$. It holds that $S_1 \neq \emptyset$ because otherwise $MinCut_1 =
       MinCut_{\delta = 0}$ which is a contradiction because then $maxFlow(\delta_1) = F$. Moreover, it holds that
       $S_1 \subseteq S_2$, since $\forall u_{i,2}' > 0,u_{i,2}' < u_{i,1}'$. Every node in the $MinCut_j$ is saturated, thus
       $\forall i \in S_1, x_{i,j}' = u_{i,j}'$. Thus $\sum\limits_{i \in S_1} x_{i,2} < \sum\limits_{i \in S_1}x_{i,1}$ and,
       since $maxFlow(\delta_1) \leq maxFlow(\delta_2)$, we conclude that for the same configurations,
       $\sum\limits_{i \in N^{+}(s) \setminus S_1} x_{i,2} > \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}$.
       However, since $x_{i,j}' \leq x_i, j \in \{1,2\}$, the configuration
       $[x_{i,1}'' = x_{i,2}', i \in N^{+}(s) \setminus S_1], [x_{i,1}'' = x_{i,1}', i \in S_1]$ is valid for
       $\delta = \delta_1$ and then $\sum\limits_{i \in S_1}x_{i,1}'' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}'' =
       \sum\limits_{i \in S_1}x_{i,1}' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,2}' > maxFlow(\delta_1)$,
       contradiction. Thus $maxFlow(\delta)$ is strictly decreasing. \qed
    \end{proof}
       We can see that if $V > 0, F' = F - V < F$ thus if $\delta \in (0, \max\limits_{i \in [n]}\{u_i\}]:
       maxFlow(\delta)= F' \Rightarrow \delta = \min||\delta_i||_\infty : maxFlow(||\delta_i||_\infty) = F'$.

    \begin{proof}[Proof of correctness for function \ref{binsearch}] \ \\
       Supposing that $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$, or equivalently
       $maxFlow(top) \leq F' - \epsilon_1 \wedge maxFlow(bot) \geq F' + \epsilon_2$, we will prove that
       $maxFlow(\delta^*) \in [F' - \epsilon_1, F' + \epsilon_2]$. \\
       First of all, we should note that if an invocation of \texttt{BinSearch} returns without calling \texttt{BinSearch}
       again (line~\ref{bsretbot} or~\ref{bsretmid}), its return value will be equal to the return value of the initial
       invocation of \texttt{BinSearch}, as we can see on lines~\ref{bsreclow} and~\ref{bsrechigh}, where the return value of
       the invoked \texttt{BinSearch} is returned without any modification. The case where \texttt{BinSearch} is called again
       is analyzed next:
       \begin{itemize}
          \item If $maxFlow(\frac{top+bot}{2}) < F' - \epsilon_1 < F'$ (line~\ref{bsiflow}) then, since $maxFlow(\delta)$ is
          strictly decreasing, $\delta^* \in [bot,\frac{top+bot}{2})$. As we see on line~\ref{bsreclow}, the interval
          $(\frac{top+bot}{2}, top]$ is discarded when the next \texttt{BinSearch} is called. Since $F' + \epsilon_2 \leq
          maxFlow(bot)$, we have $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(\frac{top+bot}{2}), maxFlow(bot)]$ and
          the length of the available interval is divided by 2.
          \item Similarly, if $maxFlow(\frac{top+bot}{2}) > F' + \epsilon_2 > F'$ (line~\ref{bsifhigh}) then $\delta^* \in
          (\frac{top+bot}{2}, top]$. According to line~\ref{bsrechigh}, the interval $[bot, \frac{top+bot}{2})$ is discarded
          when the next \texttt{BinSearch} is called. Since $F'- \epsilon_1 \geq maxFlow(top)$, we have $[F' - \epsilon_1, F'
          + \epsilon_2] \subset (maxFlow(top),$ $maxFlow(\frac{top+bot}{2})]$ and the length of the available interval is
          divided by 2.
       \end{itemize}
       As we saw, $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$ in every recursive call and
       $top - bot$ is divided by 2 in every call. From topology we know that $A \subset B \Rightarrow |A| < |B|$, so the
       recursive calls cannot continue infinitely. $|[F' - \epsilon_1, F' + \epsilon_2]| = \epsilon_1 + \epsilon_2$. Let
       $bot_0, top_0$ the input values given to the initial invocation of \texttt{BinSearch}, $bot_j,top_j$ the input
       values given to the $j$-th recursive call of \texttt{BinSearch} and $len_j =|[bot_j, top_j]| = top_j - bot_j$. We have
       $\forall j > 0, len_j = top_j - bot_j = \frac{top_{j-1} - bot_{j-1}}{2} \Rightarrow \forall j >0, len_j =
       \frac{top_0 - bot_0}{2^j}$. We understand that in the worst case $len_j = \epsilon_1 + \epsilon_2 \Rightarrow
       2^j = \frac{top_0-bot_0}{\epsilon_1 + \epsilon_2} \Rightarrow j = \log_2(\frac{top_0-bot_0}{\epsilon_1+\epsilon_2})$.
       Also, as we saw earlier, $\delta^*$ is always in the available interval, thus $maxFlow(\delta^*) \in [F' - \epsilon_1,
       F' + \epsilon_2]$. \qed
%       We will show that the output of \ref{binsearch}, $\delta \in [bot_0, top_0]$, is such that
%\subset [0, \max\limits_{i \in [n]}\{u_i\}]
%       $\sum\limits_{i=1}^{n}\max{(u_i - \delta, 0)} = F' = F - V$. \\
%       We can easily see that $\delta_1 < \delta_2 \Rightarrow \sum\limits_{i=1}^{n}\max{(u_i - \delta_1, 0)} >
%       \sum\limits_{i=1}^{n}\max{(u_i - \delta_2, 0)} \Rightarrow maxFlow_{\delta_1} \geq maxFlow_{\delta_2} (1)$.
%       The recursive function starts backtracking either on line 11, where $maxFlow = F'$, or on line 2 where $bot_j=top_j$.
%       In the latter case, it is $round(\frac{bot_{j-1}+top_{j-1}}{2}) = bot_j$ and we have either $bot_{j-1} = bot_j$ or
%       $top_{j-1} = top_j$.
%       \begin{itemize}
%          \item $bot_{j-1} = bot_j \Rightarrow round(\frac{bot_j + top_{j-1}}{2}) = bot_j \xRightarrow{top_{j-1} > bot_j}
%          bot_j < \frac{bot_j + top_{j-1}}{2} < bot_j + 0.5 \Rightarrow bot_j < top_{j-1} < bot_j + 1$ impossible.
%          \item $top_{j-1} = top_j \Rightarrow round(\frac{bot_{j-1} + top_j}{2}) = top_j \xRightarrow{top_j > bot_{j-1}}
%          top_j - 0.5 \leq \frac{bot_{j-1} + top_j}{2} < top_j \Rightarrow top_j - 1 \leq bot_{j-1} < top_j
%          \Rightarrow bot_{j-1} = top_j - 1$. In this case $round(\frac{bot_{j-1} + top_{j-1}}{2}) =
%          round(\frac{top_j - 1 + top_j}{2}) = round(top_j - 0.5) = top_j \Rightarrow
%          maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} = maxFlow_{bot_j}$. Since $bot_j$ exists, \\
%          $maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} \neq F'$.
%       \end{itemize}
%$bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j$ or $bot_{j-1} = bot_j \wedge
%       top_{j-1} = top_j + 1$.
%       \begin{itemize}
%          \item If $bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j, maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}} >F',
%          (1) \Rightarrow maxFlow_{bot_j} \leq maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}}$
%       \end{itemize}
%$\forall \delta': 0 \leq \delta' < bot_j, maxFlow > F'$ because $\exists i \in [0,j):bot_i \leq \delta' \leq top_i$
    \end{proof}
    \begin{proof}[Complexity of function \ref{binsearch}] \ \\
       Lines~\ref{bsifboteqtop} -~\ref{bsretbot} have complexity $O(1)$, lines~\ref{bsforcapset} -~\ref{bscapset} have
       complexity $O(n)$, lines~\ref{bsiflow} -~\ref{bsretmid} have complexity $O(maxFlow) + O(BinSearch)$. As we saw in the
       proof of correctness for function \ref{binsearch}, we need at most $\log_2(\frac{top - bot}{\epsilon_1 +
       \epsilon_2})$ recursive calls of \texttt{BinSearch}. Thus the function \ref{binsearch} has worst-case complexity
       $O((maxFlow + n)\log_2(\frac{top - bot}{\epsilon_1 + \epsilon_2}))$. \qed
    \end{proof}
    \begin{proof}[Proof of correctness for algorithm \ref{dinf}] \ \\
       We will show that $maxFlow \in [F - V - \epsilon_1, F - V + \epsilon_2]$, with $u_i'$ decided by algorithm
       \ref{dinf}. \\
       Obviously $maxFlow(0) = F, maxFlow(\max\limits_{i \in [n]}\{u_i\}) = 0$, thus $\delta^* \in
       \max\limits_{i \in [n]}\{u_i\}$. According to the proof of correctness for function \ref{binsearch},
       we can directly see that $maxFlow(\delta^*) \in [F - V - \epsilon_1, F - V + \epsilon_2]$, given that
       $\epsilon_1, \epsilon_2$ are chosen so that $F - V - \epsilon_1 \geq 0, F - V + \epsilon_2 \leq F$, so as to satisfy
       the condition $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$. \qed
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{dinf}] \ \\
       The complexity of lines~\ref{dinfifepsilonsvalid} -~\ref{dinfepsilonsinvalid} and~\ref{dinfifvvalid}
       -~\ref{dinfvinvalid} is $O(1)$, the complexity of lines~\ref{dinffinit},~\ref{dinfdeltainit},~\ref{dinfforcap}
       -~\ref{dinfcapset} and~\ref{dinfreturn} is $O(n)$ and the complexity of line~\ref{dinfcallbs} is $O(BinSearch) =
       O((maxFlow + n) \log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$, thus the total complexity of algorithm
       \ref{dinf} is $O((maxFlow + n)\log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$. \qed
    \end{proof}

    However, we need to minimize $\sum\limits_{i=1}^{n}(u_i-u_i') = ||\delta_i||_1$.

\end{document}
