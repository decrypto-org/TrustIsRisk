\documentclass[11pt]{llncs}
\usepackage{preamble}

\begin{document}
  Let $A \in \mathcal{V}$ source, $B \in \mathcal{V}$ sink. For the following, we suppose that $Turn_{j-1}$ has just finished
  and $A = Player\left(j\right)$ is currently deciding $Turn_j$. We use the following notation:
  \begin{align*}
     c_{Av} &= DTr_{A \rightarrow v, j-1} \\
     c'_{Av} &= DTr_{A \rightarrow v, j}
  \end{align*}
  Moreover, $X$ and $X'$ will be the flows returned by some execution of
  $MaxFlow_{\mathcal{G}_{j-1}}\left(A, B\right)$ and $MaxFlow_{\mathcal{G}_j}\left(A, B\right)$ respectively.

  Furthermore, we suppose an arbitrary ordering of the members of $N^{+}\left(A\right)$. We set $n = |N^{+}\left(A\right)|$.
  Thus
  \begin{equation*}
     N^{+}\left(A\right) = \{v_1, ..., v_n\}
  \end{equation*}
  We use these subscripts to refer to the respective capacities (a.k.a. direct trusts) and flows. Thus
  \begin{equation*}
     \begin{array}{l}
        x_i = x_{Av_i} \enspace, \\
        c_i = c_{Av_i} \enspace,
     \end{array}
     \mbox{ where } i \in [n]
  \end{equation*}

  \import{thesis/definitions/}{trustreduction.tex}
  \import{thesis/definitions/}{restrictedflow.tex}

  \import{thesis/theorems/}{saturationtheorem.tex}
  \import{thesis/proofs/}{saturationproof.tex}

  \import{thesis/theorems/}{trusttransfertheorem.tex}
  \import{thesis/proofs/}{trusttransferproof.tex}

  \import{thesis/lemmas/}{flowlimitlemma.tex}
  \import{thesis/proofs/}{flowlimitproof.tex}

  \import{thesis/theorems/}{trustsavingtheorem.tex}
  \import{thesis/proofs/}{trustsavingproof.tex}

  \import{thesis/theorems/}{invtrustrednaivetheorem.tex}
  \import{thesis/proofs/}{invtrustrednaiveproof.tex}


  Here we show three naive algorithms for calculating new direct trusts so as to maintain invariable risk when paying
  a trusted party. To prove the correctness of the algorithms, it suffices to prove that $\forall i \in [n] \:
  u_i' \leq x_i$ and that $\sum\limits_{i=1}^{n}u_i' = F - V$ where $F = \sum\limits_{i=1}^{n}x_i$. \\
  \import{thesis/algorithms/}{fcfscode.tex}
  \import{thesis/proofs/}{fcfscorrectness.tex}
  \import{thesis/proofs/}{fcfscomplexity.tex}

  \import{thesis/algorithms/}{abscode.tex}
  \noindent
  We will start by showing some results useful for the following proofs. Let $j$ be the number of iterations of the
  \textbf{while} loop for the rest of the proofs for algorithm \ref{abs} (think of $i$ from line~\ref{absiincrement}
  without the $mod\:n$).\\
  First we will show that $empty \leq n$. $empty$ is only modified on line~\ref{absemptyincrement} where it is
  incremented by 1. This happens only when $u_i' > 0$ (line~\ref{absifcappositive}), which is assigned the value 0 on
  line~\ref{abscapzero}. We can see that the incrementation of $empty$ can happen at most $n$ times because
  $|U'| = n$. Since $empty_0 = 0$, $empty \leq n$ at all times of the execution. \\
  Next we will derive the recursive formulas for the various variables. \\
  $empty_0 = 0$ \\
  $empty_{j+1} = 
     \begin{cases}
        empty_j, & u_{(j+1)\:mod\:n}' = 0 \\
        empty_j+1, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
        empty_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\ \ \\
  $reduce_0 = \frac{V}{n}$ \\
  $reduce_{j+1} =
     \begin{cases}
        reduce_j, & u_{(j+1)\:mod\:n}' = 0 \\
        reduce_j + \frac{reduce_j-x_{(j+1)\:mod\:n}}{n-empty_{j+1}}, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \:
           x_{(j+1) \:mod\:n} < reduce_j \\
        reduce_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\ \ \\
  $reduction_0 = 0$ \\
  $reduction_{j+1} =
     \begin{cases}
        reduction_j, & u_{(j+1)\:mod\:n}' = 0 \\
        reduction_j + u_{(j+1)\:mod\:n}', & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
        reduction_j + u_{(j+1)\:mod\:n}' - x_{(j+1)\:mod\:n} + reduce_{j+1}, &
           u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\
  In the end, $r = reduce$ is such that $r = \frac{V - \sum\limits_{x \in S}x}{n - |S|}$ where
  $S = \{\text{flows } y \text{ from } s \text{ to } N^{+}(s) \text{ according to } maxFlow : y < r\}$. Also,
  $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}\max{(0,x_i - r)}$. TOPROVE
  \import{thesis/proofs/}{abscorrectness.tex}
  \import{thesis/proofs/}{abscomplexity.tex}

  A variation of this algorithm using a Fibonacci heap with complexity $O(n)$ can be created, but that is part of
  further research.
  \import{thesis/proofs/}{absDinfnormminproof.tex}

  \import{thesis/algorithms/}{propcode.tex}
  \import{thesis/proofs/}{propcorrectness.tex}
  \import{thesis/proofs/}{propcomplexity.tex}

  Naive algorithms result in $u_i' \leq x_i$, thus according to \ref{invariability}, $||\delta_i||_1$ is invariable for
  any of the possible solutions $U'$, which is not necessarily the minimum (usually it will be the maximum). The following
  algorithms concentrate on minimizing two $\delta_i$ norms, $||\delta_i||_\infty$ and $||\delta_i||_1$. \\
  \import{thesis/algorithms/}{dinfmincode.tex}
  Since trust should be considered as a continuous unit and binary search dissects the possible interval for the solution
  on each recursive call, inclusion of the $\epsilon$-parameters in \texttt{BinSearch} is necessary for the algorithm to
  complete in a finite number of steps. \\
  \import{thesis/algorithms/}{dinfbinsearchcode.tex}
  \import{thesis/proofs/}{maxflowdecproof.tex}
  We can see that if $V > 0, F' = F - V < F$ thus if $\delta \in (0, \max\limits_{i \in [n]}\{u_i\}]:
  maxFlow(\delta)= F' \Rightarrow \delta = \min||\delta_i||_\infty : maxFlow(||\delta_i||_\infty) = F'$.

  \import{thesis/proofs/}{dinfbinsearchcorrectness.tex}
  \import{thesis/proofs/}{dinfbinsearchcomplexity.tex}
  \import{thesis/proofs/}{dinfmincorrectness.tex}
  \import{thesis/proofs/}{dinfmincomplexity.tex}

  However, we need to minimize $\sum\limits_{i=1}^{n}(u_i-u_i') = ||\delta_i||_1$.

\end{document}
