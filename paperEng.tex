\documentclass[11pt]{article}
\usepackage[a4paper,top=2cm,bottom=2cm,left=1.5cm,right=1.5cm]{geometry}
\usepackage{graphicx}
\usepackage[linesnumbered,ruled,noend]{algorithm2e}
%\usepackage{algorithm}
\usepackage{lipsum}
%\usepackage{algpseudocode}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{listings}

\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{corollary}
\newtheorem{corollary}{Corollary}[section]
\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[section]

\lstset{frame=tb,
%  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% PDF bookmarks
\usepackage{color,hyperref}
\definecolor{darkblue}{rgb}{0.0,0.0,0.3}
\hypersetup{colorlinks,breaklinks,
    linkcolor=darkblue,urlcolor=darkblue,
    anchorcolor=darkblue,citecolor=darkblue}

\pagestyle{fancy}{ %
    \fancyhf{} % remove everything
        \renewcommand{\headrulewidth}{0pt} % remove lines as well
        \renewcommand{\footrulewidth}{0.5pt}
        \rhead{\leftmark}
        \lhead{Decentralized financial reputation with multisig for lines-of-credit}
        \rfoot{Page \thepage\ of \pageref{LastPage}}}

\makeatletter
\def\blfootnotemark{\xdef\@thefnmark{}\@footnotemark}
\makeatother
\makeatletter
\def\blfootnote{\xdef\@thefnmark{}\@footnotetext}
\makeatother

%include number at thebibliography section
\usepackage{etoolbox}
\patchcmd{\thebibliography}{\section*}{\section}{}{} 

\begin{document}
  \begin{centering}
     \Large{\textbf{Trust Is Risk: Introducing a decentralized platform for financial trust}}
  \end{centering}
  \ \\ \ \\
  \hspace*{\fill}
  \begin{minipage}[t]{7cm}
     \begin{flushleft}
        Orfeas Stefanos Thyfronitis Litos \\
        \textit{National Technical University of Athens} \\
        \texttt{orfeas.litos@hotmail.com}
     \end{flushleft}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{7cm}
     \begin{flushright}
        Dionysis Zindros\textsuperscript{\textdagger}\blfootnotemark \\
        \textit{University of Athens} \\
        \texttt{dionyziz@di.uoa.gr}
     \end{flushright}
  \end{minipage}
  \hspace*{\fill} \\ \ \\
  \blfootnote{\textsuperscript{\textdagger}Research supported by ERC project CODAMODA, project \#259152}

  \section{Abstract}
     Reputation in centralized systems typically uses stars and review-based trust.  These systems require extensive manual
     intervention and secrecy to avoid manipulation. In decentralized systems this luxury is not available as the reputation
     system should be autonomous and open source. Previous peer-to-peer reputation systems define trust abstractly and do not
     allow for financial arguments pertaining to reputation. We propose a concrete sybil-resilient decentralized reputation
     system in which direct trust is defined as lines-of-credit using bitcoin's \cite{bitcoin} 1-of-2 multisig. We introduce
     a new model for bitcoin wallets in which user coins are split among trusted friends.  Indirect trust is subsequently
     defined using a transitive property. This enables formal game theoretic arguments pertaining to risk analysis.  Using
     our reputation model, we define financial risk and prove that risk and max flows are equivalent. We then propose several
     algorithms for the redistribution of trust so that a decision can be made on whether an anonymous third party can be
     indirectly trusted. In such a setting, the risk incurred by making a purchase from an anonymous vendor remains
     invariant. Finally, we prove the correctness of our algorithms and provide optimality arguments for various norms.

  \section{Introduction}
     Modern marketplaces can be roughly categorized as centralized and decentralized. Two major examples are
     \href{http://www.ebay.com}{ebay} and \href{https://openbazaar.org/}{OpenBazaar}. \href{http://www.ebay.com}{ebay} is
     centralized and as such it is vulnerable to ddos attacks \cite{ddosattacks} and can be considered as a single point of
     failure, it charges fees for the use of its services \cite{ebayfees} and maintains a private database of personal data,
     but it can give money-back guarantees \cite{ebayguarantee} since it is run by a single company that has a financial
     advantage in keeping its clients satisfied. On the other hand, \href{https://openbazaar.org/}{OpenBazaar} is a
     decentralized platform built on bitcoin \cite{bitcoin}, where individual stores or its \href{https://duosear.ch}{search
     engine} are vulnerable to ddos attacks \cite{ddosattacks}, but not the platform as a whole. Additionally, it does not
     charge fees for its usage \cite{openbazaar} and there is no central agent recording all the transactions alongside with
     private data \cite{openbazaar} but it is possible for a buyer or a seller colluding with a  moderator to scam the third
     party and there exists no central authority able to verify the truth of her claim and reimburse her
     \cite{multisigfraud}. Even though trust (or distrust) should be directed to each store individually, it is very likely
     that the whole platform will be discarded as untrusted by the scammed party.

     Our goal is to create a distributed marketplace where the trust each user gives to the rest of the users is
     quantifiable, measurable and expressable in monetary terms. The central concept used throughout this paper is
     trust-as-risk, or the proposition that a user's $A$ \textit{trust} to another user $B$ is defined to be the
     \textit{maximum sum of money} $A$ can lose when $B$ is free to choose any strategy she wants. To flesh out
     trust-as-risk, we will use \textit{lines of credit} as proposed by Washington Sanchez \cite{loc}. Joining the network
     will be done by explicitly entrusting a certain amount of money to another user. If the second user has already
     entrusted an amount of money to a store, then we trust indirectly the store, thus we can engage in economic interaction
     with said store.

     We thus propose a new kind of wallet where coins are not stored locally, but are placed in 1-of-2 multisigs, a bitcoin
     construction that permits any one of two pre-designated users to spend the coins contained therein \cite{multisig}.

     Our approach drastically changes the user experience. A user no more has to worry about stars and ratings to develop
     trust towards a store, she can simply check the trust \textit{flowing} from her to the store (which will be a number
     expressed in bitcoins) and if this number exceeds the price of the product, she is safe to complete the transaction
     after modifying her direct trust towards her friends in an appropriate way, a process that can be handled by one of
     several algorithms that we propose, or in any custom way the user chooses to. On the other side, there is no guarantee
     that the store will complete is part of the transaction and no central authority can reimburse the money. However, it is
     possible for the defrauded user to make up for her loss by in turn stealing from other users that trust her, an action
     that will tautologically reduce their trust to her. The fact that this system can function in a completely distributed
     fashion will become clear in the following sections, along with the positive result that it is in principle Sybil
     resilient.

     There are several incentives for a user to join this network. First of all, they can have access to a store that is
     otherwise unaccessible. Moreover, two friends can formalize their mutual trust by entrusting the same amount to each
     other. A large company that casually subcontracts other companies to complete various tasks can express its trust
     towards them using this method. A government can choose to entrust its citizens with money and confront them using its
     legal arsenal if they make irresponsible use of this trust. A bank can provide loans as outgoing and manage savings as
     incoming trust and thus has a unique opportunity of expressing in a formal and absolute way its credence by publishing
     its incoming trust. Last but not least, the network can be viewed as a possible field for investment and speculation
     since it constitutes a completely new area for financial activity.

     We should note that the current description of TrustIsRisk refers to a static setting where the game evolves in turns.
     In each turn only one user changes the state of the network. Also the system we describe needs full network knowledge
     for all of the users, a situation that may be undesirable because of the privacy-invading implications it brings.
     Future work is needed to address both limitations.

  \section{Keywords}
     decentralized, trust, web-of-trust, bitcoin, multisig, line-of-credit, trust-as-risk, flow  

  \section{A detailed example}
     The state of the game at any given moment can be represented by a directed weighted graph where each node represents a
     pseudonymous identity that is considered to correspond to exactly one user and each edge represents a direct trust, the
     weight of which is the value which the head entrusts the tail with. [Image] \\
     Each node has a corresponding non-negative number that represents its capital. A node's capital is the total value that
     the node directly and exclusively controls. More technically, it is the number of bitcoins contained in p2pkh
     transactions in the utxo of which the private keys are controlled by the node. A rational player would like to maximize
     her capital in the long term. Let's suppose that player $A$ wants to buy a product that costs $10$ from player $B$, but
     $A$ has not given any direct trust to $B$. Does $A$'s friends trust $B$ enough so that $A$ can buy the product? In other
     words, should $B$ decide to steal all its incoming direct trust and stop trusting directly other users and the rest of
     the players choose the conservative strategy of stealing from their respective incoming trusts just enough to replenish
     their loss [rationale needed], what would the eventual loss of $A$ be? If it can be higher than the value of the
     product, then $A$ is already exposed to a higher risk to $B$, thus paying for the product can be done without $A$ being
     exposed to any additional risk towards $B$, as long as $A$ reduces the direct trust to her friends enough to reduce the
     risk by the value of the product. If the transaction completes in a satisfying manner, $A$ can replenish the reduced
     trust to her friends, or can even choose to start directly trusting $B$. \\
     Suppose that at the moment $A$ is considering of performing a payment to him, $B$ really decides to depart from the
     network, taking with him all the coins he can. A chain reaction starts throughout the network because each player that
     $B$ exploited is expected to steal enough value from other users that directly trust her to replenish all the value she
     lost to $B$, the newly exploited users will act in the same way and so on, until a new equilibrium is reached
     (\ref{convergence}). Going into detail, [Image] \\
     (Completion of example)

  \section{Definitions}
     \begin{definition}[Graph] \ \\
        TrustIsRisk is represented by a sequence of weighted directed graphs $(\mathcal{G}_j)$ where $\mathcal{G}_j =
        (\mathcal{V}_j, \mathcal{E}_j), j \in \mathbb{N}$. Members of $\mathcal{E}_j$ are tuples of two nodes from
        $\mathcal{V}_j$. More formally, $e \in \mathcal{E}_j \Rightarrow \exists A,B \in \mathcal{V}_j : e = (A,B)$.
        Also, since the graphs are weighted, there exists a sequence of functions $(c_j)$ with $c_j : \mathcal{E}_j
        \rightarrow \mathbb{R}^{+}$.
     \end{definition}
     \begin{definition}[Players] \ \\
        The set $\mathcal{V}_j = V(\mathcal{G}_j)$ is the set of all players in the network, otherwise understood as the
        set of all pseudonymous identities.
     \end{definition}
     \begin{definition}[Capital of $A$, $Cap_A$] \ \\
       Total amount of value that exists in P2PKH in the UTXO and can be spent by $A$. We also define $Cap_{A,j}$ as
       the total amount of value that exists in P2PKH in the UTXO and can be spent by $A$ during turn $j$.
     \end{definition}
     \begin{definition}[Direct Trust from $A$ to $B$ after turn $j$, $DTr_{A \rightarrow B, j}$] \ \\
        Total amount of value that exists in 1/$\{A,B\}$ multisigs in the UTXO in the end of turn $j$, where the money is
        deposited by $A$.
        $$DTr_{A \rightarrow B, j} =
           \begin{cases}
              c_j(A, B), & if (A, B) \in \mathcal{E}_j \\
              0, & if (A, B) \notin \mathcal{E}_j
           \end{cases}$$
        A function or algorithm that has access to the graph $\mathcal{G}_j$ has implicitly access to all direct trusts
        of this graph. The exception are the oracles, which in this case have access only to their incoming and outgoing
        direct trusts.
     \end{definition}
     \begin{definition}[(In/Out) Neighbourhood of $A$ on turn $j$, $N^{+}(A)_j, N^{-}(A)_j, N(A)_j$] \ 
        \begin{enumerate}
           \item Let $N^{+}(A)_j$ be the set of players $B$ that $A$ directly trusts with any positive value at the end of
              turn $j$. More formally, $N^{+}(A)_j = \{B \in \mathcal{V}_j : DTr_{A \rightarrow B, j} > 0\}$. $N^{+}(A)_j$
              is called out neighbourhood of $A$ on turn $j$. Let also $S \subset \mathcal{V}_j$. $N^{+}(S)_j =
              \bigcup\limits_{A \in S}N^{+}(A)_j$.
           \item Let $N^{-}(A)_j$ be the set of players $B$ that directly trust $A$ with any positive value at the end of
              turn $j$. More formally, $N^{-}(A)_j = \{B \in \mathcal{V}_j : DTr_{B \rightarrow A, j} > 0\}$. $N^{-}(A)_j$
              is called in neighbourhood of $A$ on turn $j$. Let also $S \subset \mathcal{V}_j$. $N^{-}(S)_j =
              \bigcup\limits_{A \in S}N^{-}(A)_j$.
           \item Let $N(A)_j$ be the set of players $B$ that either directly trust or are directly trusted by $A$ with
              any positive value at the end of turn $j$. More formally, $N(A)_j = N^{+}(A)_j \cup N^{-}(A)_j$. $N(A)_j$ is
              called neighbourhood of $A$ on turn $j$. Let also $S \subset \mathcal{V}_j$.
              $N(S)_j = N^{+}(S)_j \cup N^{-}(S)_j$.
           \item Let $N(A)_{j,i}$ (respectively $N^{+}(A)_{j,i}, N^{-}(A)_{j,i}, N(S)_{j,i}, N^{+}(S)_{j,i}, N^{-}(S)_{j,i},
              S \subset \mathcal{V}_j$) be the $i$-th element of set $N(A)_j$ (respectively of $N^{+}(A)_j, N^{-}(A)_j,
              N(S)_j, N^{+}(S)_j, N^{-}(S)_j$), according to an arbitrary but fixed enumeration of the set players.
        \end{enumerate}
     \end{definition}
     \begin{definition}[Total incoming/outgoing trust of $A$ in turn $j$, $in_{A, j}, out_{A, j}$] \ \\
        $$in_{A, j} = \sum\limits_{v \in N^{-}(A)_j}DTr_{v \rightarrow A, j}$$
        $$out_{A, j} = \sum\limits_{v \in N^{+}(A)_j}DTr_{A \rightarrow v, j}$$
     \end{definition}
%      \begin{definition}[$B$ steals $x$ from $A$] \ \\
%         $B$ steals value $x$ from $A$ when $B$ reduces the $DTr_{A \rightarrow B}$ by $x$ and increases $Cap_B$ by $x$.
%         This makes sense when $x \leq DTr_{A \rightarrow B}$.
%      \end{definition}
     \begin{definition}[Turns] \ \\
        The game we are describing is turn-based. Let $DTr_{B \rightarrow A, j}$ be $B$'s direct trust to $A$ in turn $j$.
        In each turn $j$ exactly one player $A \in \mathcal{V}, A = Player(j)$, chooses an action (according to a certain
        strategy) that can be one of the following, or a finite combination thereof:
        \begin{enumerate}
           \item Steal value $y_B, 0 \leq y_B \leq DTr_{B \rightarrow A, j-1}$ from $B \in N^{-}(A)$.
           $DTr_{B \rightarrow A, j} = DTr_{B \rightarrow A, j-1} - y_B$. ($Steal(y_B, B)$)
           \item Add value $y_B, -DTr_{A \rightarrow B, j-1} \leq y_B$ to $B \in \mathcal{V}$.
           $DTr_{A \rightarrow B, j} = DTr_{A \rightarrow B, j-1} + y_B$. When $y_B < 0$, we say that $A$ reduces her trust
           to $B$ by $-y_B$, when $y_B > 0$, we say that $A$ increases her trust to $B$ by $y_B$.
           If $DTr_{A \rightarrow B, j-1} = 0$, then we say that $A$ starts directly trusting $B$. ($Add(y_B, B)$)
        \end{enumerate}
        If player $A$ chooses no action in her turn, we say that she passes her turn. Also, let $Y_{st}, Y_{add}$ be the
        total value to be stolen and added respectively by $A$ in her turn, $j$. For a turn to be feasible, it must hold
        that $Y_{add} - Y_{st} \leq Cap_{A, j-1}$. We set $Cap_{A, j} = Cap_{A, j-1} + Y_{st} - Y_{add}$. Moreover, player
        $A$ is not allowed to choose two actions of the same kind against the same player in the same turn. \\
        The set of actions a player makes in turn $j$ is $Turn_j$. Examples:
        \begin{itemize}
           \item $Turn_{j_1} = \emptyset$
           \item $Turn_{j_2} = \{Steal(y, B), Add(w, B)\}$ (given that $DTr_{B \rightarrow A, j_2 - 1} \leq y \wedge
           -DTr_{A \rightarrow B, j_2 - 1} \leq w \wedge y - w \leq Cap_{A, j_2-1}$, where $A = Player(j_2)$)
           \item $Turn_{j_3} = \{Steal(x, B), Add(y, C), Add(w, D)\}$ (given that $DTr_{B \rightarrow A, j_3 - 1} \leq x
           \wedge -DTr_{A \rightarrow C, j_3-1} \leq y \wedge -DTr_{A \rightarrow D, j_3 - 1} \leq w \wedge
           x - y - w \leq Cap_{A, j_3-1}$, where $A = Player(j_3)$)
           \item $Turn_{j_4} = \{Steal(x, B), Steal(y, B)\}$ is not a valid turn because it contains two $Steal()$ actions
           against the same player. If $x + y \leq DTr_{B \rightarrow A}$, the correct alternative would be $Turn_{j_4} =
           \{Steal(x+y, B)\}$, where $A = Player(j_4)$.
        \end{itemize}
     \end{definition}
     \begin{definition}[Previous/Next turn of a player] \ \\
        Let $j \in \mathbb{N}$ a turn with $Player(j) = A$. We define $prev(j), next(j)$ as the previous and next turn
        that $A$ is chosen to play respectively. If $j$ is the first turn that $A$ plays, $prev(j) = 0$. More formally,
        $$prev(j) = \begin{cases}
           \max{\{k \in \mathbb{N} : k < j \wedge Player(k) = A\}}, & \{k \in \mathbb{N} : k < j \wedge Player(k) = A\}
           \neq \emptyset \\
           0, & \{k \in \mathbb{N} : k < j \wedge Player(k) = A\} = \emptyset
        \end{cases}$$
        $$next(j) = \min{\{k \in \mathbb{N} : k > j \wedge Player(k) = A\}}$$
        $next(j)$ is always well defined with the assumption that eventually everybody plays.
     \end{definition}
     \begin{definition}[$A$ is stolen $x$] \ \\
        Let $j, j'$ be two consecutive turns of $A$ ($next(j) = j'$). We say that $A$ has been stolen a value $x$ between
        $j$ and $j'$ if $out_{A,j} - out_{A,j'} = x > 0$. If turns are not specified, we implicitly refer to the current
        and the previous turns.
     \end{definition}
     \begin{definition}[History] \ \\
        We define History, $\mathcal{H} = (\mathcal{H}_j)$, as the sequence of all the tuples containing the sets of actions
        and the corresponding player. $\mathcal{H}_j = (Player(j), Turn_j)$.
     \end{definition}
     \begin{definition}[Conservative strategy] \ \\
        A player $A$ is said to follow the conservative strategy in turn $j$ if for any value $x$ that has been stolen from
        her since the previous turn she played, she substitutes it in her turn by stealing from others that trust her value
        equal to $\min{(x,in_{A,j})}$ and she takes no other action.
        More formally, let $j' = prev(j), Damage_j = out_{A,j'} - out_{A,j-1}$. If $Strategy(A) = Conservative$, then
        $\forall j \in \mathbb{N}: Player(j) = A$ it is $$Turn_j =
        \begin{cases}
           \emptyset, & Damage_j \leq 0 \\
           \bigcup\limits_{i=1}^{k}\{Steal(y_i,v_i)\}, & Damage_j > 0, N^{-}(A)_j = \{v_1,...,v_k\}
        \end{cases}$$
        In the second case, it is $\sum\limits_{i=1}^{k}y_i = \min(in_{A,j-1}, Damage_j)$. \\
%         If $j$ is the first turn in which $A$ plays, $j'$ is not well defined. In this case, we choose $Turn_j = \emptyset$,
%         except if it is otherwise denoted in some special cases. \\
     \end{definition}
     As we can see, the definition covers a multitude of options for the conservative player, since in case $0 < Damage_j <
     in_{A,j-1}$ she can choose to distribute the $Steal(s)()$ in any way she chooses, as long as $\forall i, y_i \leq
     DTr_{N^{-}(A)_{j,i} \rightarrow A, j-1} \wedge \sum\limits_{i=1}^{|N^{-}(A)_j|}y_i = Damage_j$.
     The oracle remembers $PrevOutTrust = out_{A, j'}$ for  $j' = prev(j)$ and can observe all incoming and outgoing direct
     trusts of player $A$, $\forall v \in N^{-}(A)_{j-1}, DTr_{v \rightarrow A, j-1}, \forall v \in N^{+}(A)_{j-1},
     DTr_{A \rightarrow v, j-1}$. We note that $N(A)_{j-1} = N(A)_j$. \\
     \begin{algorithm}[H]
        \label{conservativeoracle}
        \SetKwInOut{Input}{Input}
        \SetKwInOut{Output}{Output}
        \SetKwFunction{SelectSteal}{SelectSteal}
        \Input{previous graph $\mathcal{G}_{j-1}$}
        \Output{$Turn_j$}
        \caption{Conservative Oracle}
        $\mathcal{O}_{cons}(\mathcal{G}_{j-1})$ : \\ {
           $NewOutTrust \gets \sum\limits_{v \in N^{+}(A)_{j-1}}DTr_{A \rightarrow v, j-1}$ \\
           $NewInTrust \gets \sum\limits_{v \in N^{-}(A)_{j-1}}DTr_{v \rightarrow A, j-1}$ \\
           $Damage \gets PrevOutTrust - NewOutTrust$ \\
           \If{$Damage > 0$}{
              \If{$Damage \geq NewInTrust$}{
                 $Turn_j \gets \emptyset$ \\
                 \For{$v \in N^{-}(A)_{j-1}$}{
                    $Turn_j \gets Turn_j \cup \{Steal(DTr_{v \rightarrow A, j-1}, v)\}$}}
              \Else{
                 $(y_1,...,y_{|N^{-}(A)_{j-1}|}) \gets$ \SelectSteal{$DTr_{N^{-}(A)_{j-1,1} \rightarrow A, j-1}$,$...$,
                   $DTr_{N^{-}(A)_{j-1,|N^{-}(A)_{j-1}|} \rightarrow A, j-1}$,$Damage$} \\
                 $Turn_j \gets \emptyset$ \\
                 \For{$i \gets 1$ to $|N^{-}(A)_{j-1}|$}{
                    $Turn_j \gets Turn_j \cup \{Steal(y_i, N^{-}(A)_{j-1,i})\}$}}}
           \Else{$Turn_j \gets \emptyset$}
           \Return{$Turn_j$}}
     \end{algorithm}
     \texttt{SelectSteal()} returns $y_i, i \in [|N^{-}(A)_j|] : \forall i, y_i \leq DTr_{N^{-}(A)_{j,i} \rightarrow A},
     \sum\limits_{i=1}^{|N^{-}(A)_j|}y_i = Damage$.
     \begin{definition}[Idle strategy] \ \\
        A player $A$ is said to follow the idle strategy if she passes in her turn. More formally, if $Strategy(A) =
        Idle$, then $\forall j \in \mathbb{N} : Player(j) = A$ it is $Turn_j = \emptyset$.
     \end{definition}
     \begin{algorithm}[H]
        \label{idleoracle}
        \SetKwInOut{Input}{Input}
        \SetKwInOut{Output}{Output}
        \Input{previous graph $\mathcal{G}_{j-1}$}
        \Output{$Turn_j$}
        \caption{Idle Oracle}
        $\mathcal{O}_{idle}(\mathcal{G}_{j-1})$ : \\ {
           \Return{$\emptyset$}}
     \end{algorithm}
     \begin{definition}[Evil strategy] \ \\
        A player $A$ is said to follow the evil strategy if she steals value $y_B = DTr_{B \rightarrow A, j-1} \:
        \forall \: B \in N^{-}(A)_j$ (steals all incoming direct trust) and reduces her trust to $C$ by
        $DTr_{A \rightarrow C, j-1} \: \forall \: C \in N^{+}(A)_j$ (nullifies her outgoing direct trust) in her turn.
        More formally, if $Strategy(A) = Evil$, then $\forall j \in \mathbb{N} : Player(j) = A$ it is $Turn_j =
        \{Steal(y_1,N^{-}(A)_{j,1}),...,Steal(y_m,N^{-}(A)_{j,m}), Add(w_1,N^{+}(A)_{j,1}),...,Add(w_l,N^{+}(A)_{j,l})\}$ 
        where $m = |N^{-}(A)_j|, l = |N^{+}(A)_j|, \forall i \in [m], y_i = DTr_{N^{-}(A)_{j,i} \rightarrow A, j-1},
        \forall i \in [l], w_i = -DTr_{A \rightarrow N^{+}(A)_{j,i},j-1}$. We note again that $N(A)_{j-1} = N(A)_j$.
     \end{definition}
     \begin{algorithm}[H]
        \label{eviloracle}
        \SetKwInOut{Input}{Input}
        \SetKwInOut{Output}{Output}
        \Input{previous graph $\mathcal{G}_{j-1}$}
        \Output{$Turn_j$}
        \caption{Evil Oracle}
        $\mathcal{O}_{evil}(\mathcal{G}_{j-1})$ : \\ {
           $Turn_j \gets \emptyset$ \\
           \For{$v \in N^{-}(A)_{j-1}$}{
              $Turn_j \gets Turn_j \cup \{Steal(DTr_{v \rightarrow A, j-1}, v)\}$}
           \For{$w \in N^{+}(A)_{j-1}$}{
              $Turn_j \gets Turn_j \cup \{Add(-DTr_{A \rightarrow v, j-1}, w)\}$}
           \Return{$Turn_j$}}
     \end{algorithm}
     \begin{definition}[Indirect trust from $A \in \mathcal{V}_j$ to $B \in \mathcal{V}_j$, $Tr_{A \rightarrow B, j}$] \ \\
        Maximum possible value that can be stolen from $A$ if $B$ follows the evil strategy, $A$ follows the idle strategy
        and everyone else ($\mathcal{V} \setminus \{A,B\}$) follows the conservative strategy. More formally,
        $$Tr_{A \rightarrow B, j} = \max\limits_{j' : j' > j, configurations}{[out_{A,j} - out_{A,j'}]}$$ where
        $Strategy(A) = Idle, Strategy(B) = Evil, \forall C \in \mathcal{V} \setminus \{A,B\}, Strategy(C) = Conservative$.
     \end{definition}
     \begin{definition}[Indirect trust from $A \in \mathcal{V}_j$ to $S \subset \mathcal{V}_j$, $Tr_{A \rightarrow S, j}$]
        \ \\Maximum possible value that can be stolen from $A$ if all players in $S$ follow the evil strategy, $A$ follows
        the idle strategy and everyone else ($\mathcal{V} \setminus (S \cup \{A\})$) follows the conservative strategy. More
        formally, $$Tr_{A \rightarrow S, j} = \max\limits_{j' : j' > j, configurations}{[out_{A,j} - out_{A,j'}]}$$ where
        $Strategy(A) = Idle, \forall E \in S, Strategy(E) = Evil,
        \forall C \in \mathcal{V} \setminus \{A,E\}, Strategy(C) = Conservative$.
     \end{definition}
     \begin{definition}[Trust Reduction] \ \\
        Let $A, B \in \mathcal{V}, x_i$ flow to $N^{+}(A)_i$ resulting from $maxFlow(A,B), u_i =
        DTr_{A \rightarrow N^{+}(A)_i,j-1}, u_i' = DTr_{A \rightarrow N^{+}(A)_i,j},$ \\ $i \in [|N^{+}(A)|],
        j \in \mathbb{N}$.
        \begin{enumerate}
           \item The Trust Reduction on neighbour $i, \delta_i$ is defined as $\delta_i = u_i - u_i'$.
           \item The Flow Reduction on neigbour $i, \Delta_i$ is defined as $\Delta_i = x_i - u_i'$.
        \end{enumerate}
        We will also use the standard notation for 1-norm and $\infty$-norm, that is:
        \begin{enumerate}
           \item $||\delta_i||_1 = \sum\limits_{i \in N^{+}(A)}\delta_i$
           \item $||\delta_i||_\infty = \max\limits_{i \in N^{+}(A)}\delta_i$.
        \end{enumerate}
     \end{definition}
     \begin{definition}[Restricted Flow] \ \\
        Let $A, B \in \mathcal{V}, i \in [|N^{+}(A)|]$.
        \begin{enumerate}
           \item Let $F_{A_i \rightarrow B}$ be the flow from $A$ to $N^{+}(A)_i$ as calculated by the $maxFlow(A,B)$
              ($x_i'$) when $u_i' = u_i,$ \\ $u_k' = 0 \:\forall k \in [|N^{+}(A)|] \wedge k \neq i$.
           \item Let $S \subset N^{+}(A)$. Let $F_{A_S \rightarrow B}$ be the sum of flows from $A$ to $S$ as
              calculated by the $maxFlow(A,B)$ ($\sum\limits_{i=1}^{|S|}x_i'$) when $u_C' = u_C \: \forall C \in S,
              u_D' = 0 \: \forall D \in N^{+}(A) \setminus S$.
        \end{enumerate}
     \end{definition}
     \begin{definition}[Collusion] \ \\
        A collusion of players $S \subset \mathcal{V}$ is a set of players that is entirely controlled by a single entity in
        the physical world. From a game theoretic point of view, other players ($v \in \mathcal{V} \setminus S$) perceive
        the collusion as independent players with a distinct strategy each, whereas in reality they are all subject to a
        single strategy dictated by the controlling entity.
     \end{definition}
  \section{Theorems-Algorithms}
    The following algorithm has read access to direct trusts in $\mathcal{G}_{j-1}$ and write access to direct trusts in
    $\mathcal{G}_j$.
    \begin{algorithm}[H]
       \label{executeturn}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{validateTurn}{validateTurn}
       \SetKwFunction{commitTurn}{commitTurn}
       \SetKwFunction{executeTurn}{executeTurn}
       \Input{player $A$, old graph $\mathcal{G}_{j-1}$, old capital $Cap_{A, j-1}$, $ProvisionalTurn$}
       \Output{new graph $\mathcal{G}_j$, new capital $Cap_{A, j}$, new history $\mathcal{H}_j$}
       \caption{Execute Turn}
       \executeTurn{$A$, $\mathcal{G}_{j-1}$, $Cap_{A, j-1}$, $ProvisionalTurn$} : \\ {
          $(Turn_j, NewCap) \gets$ \validateTurn{$A$, $\mathcal{G}_{j-1}$, $Cap_{A, j-1}$, $ProvisionalTurn$} \\
          \Return{\commitTurn{$A$, $mathcal{G}_{j-1}$, $NewCap$, $Turn_j$}}} 
    \end{algorithm}
    \begin{algorithm}[H]
       \label{validateturn}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{validateTurn}{validateTurn}
       \Input{player $A$, old graph $\mathcal{G}_{j-1}$, old capital $Cap_{A, j-1}$, $ProvisionalTurn$}
       \Output{$Turn_j$, new capital $Cap_{A, j}$}
       \caption{Validate Turn}
       \validateTurn{$A$, $\mathcal{G}_{j-1}$, $Cap_{A, j-1}$, $ProvisionalTurn$} : { \\
          $Y_{st} \gets 0$ \\
          $Y_{add} \gets 0$ \\
          \For{$action \in ProvisionalTurn$}{
             $action$ \textbf{match do} \\ {
                \textbf{case} $Steal(y,w)$ \textbf{do} \\ {
                   \If{$y > DTr_{w \rightarrow A,j-1} \vee y < 0$}{
                      \Return{$\emptyset$, $Cap_{A, j-1}$}}
                   \Else{$Y_{st} \gets Y_{st} + y$}}
                \textbf{case} $Add(y,w)$ \textbf{do} \\ {
                   \If{$y < -DTr_{A \rightarrow w,j-1}$}{
                      \Return{$\emptyset$, $Cap_{A, j-1}$}}
                   \Else{$Y_{add} \gets Y_{add} + y$}}}}
          \If{$Y_{add} - Y_{st} > Cap_{A, j-1}$}{
             \Return{$\emptyset$, $Cap_{A, j-1}$}}
          \Else{\Return{$ProvisionalTurn$, $Cap_{A, j-1} + Y_{st} - Y_{add}$}}}
    \end{algorithm}
    \begin{algorithm}[H]
       \label{committurn}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{commitTurn}{commitTurn}
       \Input{player $A$, old graph $\mathcal{G}_{j-1}$, old capital $Cap_{A, j-1}$, $ProvisionalTurn$}
       \Output{new graph $\mathcal{G}_j$, new capital $Cap_{A, j}$, new history $\mathcal{H}_j$}
       \caption{Commit Turn}
       \commitTurn{$A$, $\mathcal{G}_{j-1}$, $Cap_{A, j-1}$, $Turn_j$} : { \\
          \For{$(v, w) \in \mathcal{E}_j$}{
                $DTr_{v \rightarrow w, j} \gets DTr_{v \rightarrow w, j-1}$}
          \For{$action \in Turn_j$}{
             $action$ \textbf{match do} \\ {
               \textbf{case} $Steal(y,w)$ \textbf{do} \\ {
                  $DTr_{w \rightarrow A, j} \gets DTr_{w \rightarrow A, j-1} - y$} \\
               \textbf{case} $Add(y,w)$ \textbf{do} \\ {
                  $DTr_{A \rightarrow w, j} \gets DTr_{A \rightarrow w, j} + y$}}}
          $Cap_{A, j} \gets NewCap$ \\
          $\mathcal{H}_j \gets (Player(j), Turn_j)$} \\
          \Return{$\mathcal{G}_j$, $Cap_{A, j}$, $\mathcal{H}_j$}
    \end{algorithm}
    \begin{algorithm}[H]
       \label{trustisriskgame}
%       \SetKwInOut{Input}{Input}
%       \SetKwInOut{Output}{Output}
       \SetKwFunction{executeTurn}{executeTurn}
       \caption{TrustIsRisk Game}
       $j \gets 0$ \\
       \While{True}{
          $j \gets j + 1$ \\
          $v \overset{\$}{\gets} \mathcal{V}_j$ \\
          $ProvisionalTurn \gets \mathcal{O}_v(\mathcal{G}_{j-1})$ \\
          $(G_j, Cap_{v, j}, H_j) \gets$ \executeTurn{$v$, $\mathcal{G}_{j-1}$, $Cap_{v, j-1}$, $ProvisionalTurn$}}
    \end{algorithm}

    On turn $0$, there is already a network in place. \\
    \begin{algorithm}[H]
       \label{transitivesteal}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{executeTurn}{executeTurn}
       \Input{$A$ idle player, $E$ evil player}
       \Output{$\mathcal{H}$ history}
       \caption{Transitive Steal}
       $Angry \gets \emptyset$ \\
       $Happy \gets \emptyset$ \\
       $Sad \gets \emptyset$ \label{trstealsadinit}\\
       \For{$v \in \mathcal{V}_{0} \setminus \{E\}$}{
          $Loss_v \gets 0$ \label{trsteallossinit}\\
          \If{$v \neq A$}{
             $Happy \gets Happy \cup \{v\}$}}
       $j \gets 0$ \\
       \While{True}
          {$j \gets j + 1$ \\
           $v \overset{\$}{\gets} \mathcal{V}_j \setminus\{A\}$ \\
           $Turn_j \gets \mathcal{O}_v(\mathcal{G}_{j-1})$ \\ %\Comment{$\mathcal{O}_v = \mathcal{O}_{idle}$} \\
           \executeTurn{$\mathcal{G}_{j-1}$, $Cap_{v, j-1}$, $Turn_j$} \\
           \For{$action \in Turn_j$}{
              $action$ \textbf{match do}{ \\
                 \textbf{case} $Steal(y, w)$ \textbf{do}{ \\
                    $exchange \gets y$ \\
                    $Loss_w \gets Loss_w + exchange$ \label{trsteallossincrease}\\
                    \If{$v \neq E$}{
                       $Loss_v \gets Loss_v - exchange$} \label{trsteallossdecrease}
                    \If{$w \neq A$}{
                       $Happy \gets Happy \setminus \{w\}$ \\
                       \If{$in_{w, j} = 0$}
                          {$Sad \gets Sad \cup \{w\}$}
                       \Else{$Angry \gets Angry \cup \{w\}$}}}}}
           $Angry \gets Angry \setminus \{v\}$ \\
           \If{$in_{v, j} = 0 \wedge Loss_v > 0$ \label{trstealifentersad}}{
               $Sad \gets Sad \cup \{v\}$} \label{trstealtrueentersad}
           \If{$Loss_v = 0$}{
               $Happy \gets Happy \cup \{v\}$}}
    \end{algorithm}
    Let $j_0$ be the first turn on which $E$ is chosen to play. Until then, according to theorem \ref{conservativeworld},
    all players will pass their turn.
    Given that $Damage_{v,j} = out_{v,j'} - out_{v,j}$ where $j' = prev(j)$, the algorithm generates turns:
    $$Turn_j =
      \begin{cases}
         \emptyset, & Damage_{v,j-1} = 0 \\
         \bigcup\limits_{i=1}^{k}\{Steal(y_i,v_i)\}, & Damage_j > 0, N^{-}(A)_j = \{v_1,...,v_k\}
      \end{cases}$$
    In the second case, it is $\sum\limits_{i=1}^{k}y_i = \min(in_{v, j-1}, Damage_{v, j-1})$. From the
    definition of $Damage_{v,j}$ and knowing that no strategy in this case can increase any direct trust, it is obvious
    that $Damage_{v,j} \geq 0$. Also, we can see that $Loss_{v,j} \geq 0$
    because if $Loss_{v,j} < 0$, then $v$ has stolen more value than she has been stolen, thus she would not be following the
    conservative strategy.
    \begin{lemma}[$Loss$ equivalent to $Damage$] \ \\
       Let $j \in \mathbb{N}, v \in \mathcal{V}_j \setminus \{A, E\}, v = Player(j)$. Then $\min(in_{v, j}, Loss_{v, j}) = 
       \min(in_{v, j}, Damage_{v, j})$.
    \end{lemma}
    \begin{proof} \ 
       $j \in \mathbb{N}: v = Player(j)$.
       \begin{itemize}
          \item $v \in Happy_{j-1}$. Then
          \begin{enumerate}
             \item $v \in Happy_j$ because $Turn_{j} = \emptyset$,
             \item $Loss_{v, j} = 0$ because otherwise $v \notin Happy_j$,
             \item $Damage_{v, j} = 0$, or else any reduction in direct trust to $v$ would increase equally
             $Loss_{v, j}$ (line~\ref{trsteallossincrease}), which cannot be decreased again but during an Angry player's turn
             (line~\ref{trsteallossdecrease}).
             \item $in_{v, j} \geq 0$
          \end{enumerate}
          Thus $\min(in_{v, j}, Damage_{v,j}) = \min(in_{v, j}, Loss_{v,j}) = 0$.
          \item $v \in Sad_{j-1}$. Then
          \begin{enumerate}
             \item $v \in Sad_j$ because $Turn_{j} = \emptyset$, 
             \item $in_{v, j} = 0$ (lines~\ref{trstealifentersad} -~\ref{trstealtrueentersad}),
             \item $Damage_{v, j} \geq 0 \wedge Loss_{v, j} \geq 0$.
          \end{enumerate}
          Thus $\min(in_{v, j}, Damage_{v,j}) = \min(in_{v, j}, Loss_{v,j}) = 0$.
          \item $v \in Angry_{j-1} \wedge v \in Happy_j$. Then the same argument as in the first case holds, if
          we ignore the argument (1).
          \item $v \in Angry_j \wedge v \in Sad_j$. Then the same argument as in the second case holds, if 
          we ignore the argument (1).
       \end{itemize}
    \end{proof}

    \begin{theorem}[Trust convergence theorem] \ \\
       \label{convergence}
       Let $A,E \in \mathcal{V} : Strategy(A) = Idle$, $Strategy(E) = Evil$, $\forall C \in \mathcal{V} \setminus \{A,E\},
       Strategy(C) = Conservative$ and $j_0 \in \mathbb{N} : Player(j_0) = E$. Given that all players eventually play, there
       exists a turn $j' > j_0 : \forall j \geq j', Turn_j = \emptyset$.
    \end{theorem}
    \begin{proof}
       First of all, $\forall j > j_0 : Player(j) = E \Rightarrow Turn_j = \emptyset$ because $E$ has already nullified his
       incoming and outgoing direct trusts in $Turn_{j_0}$, the evil strategy does not contain any case where direct trust is
       increased or where the evil player starts directly trusting another player and the other players do not follow a
       strategy in which they can choose to $Add()$ trust to $E$, thus player $E$ can do nothing $\forall j > j_0$. Also
       $\forall j > j_0 : Player(j) = A \Rightarrow Turn_j = \emptyset$ because of the idle strategy that $A$ follows. As far
       as the rest of the players are concerned, consider the algorithm \ref{transitivesteal}, which is a variation of the
       TrustIsRisk Game. \\
       As we can see from lines~\ref{trsteallossinit} and~\ref{trsteallossincrease} -~\ref{trsteallossdecrease}, $\forall j,
       \sum\limits_{v \in \mathcal{V}_j}Loss_v = in_{E, j_0-1}$, that is the total loss is constant and equal to the total
       value stolen by $E$. Also, as we can see in lines~\ref{trstealsadinit} and~\ref{trstealtrueentersad}, which are the
       only lines where the $Sad$ set is modified, once a player enters the $Sad$ set, it is impossible to exit from this
       set. Also, we can see that players in $Sad \cup Happy$ always pass their turn. We will now show that eventually the
       $Angry$ set will be empty, or equivalently that eventually every player will pass their turn. Suppose that it is
       possible to have an infinite amount of turns that players do not choose to pass. We know that the number of nodes is
       finite, thus this is possible only if $\exists j_1: \forall j \geq j_1, |Angry_j \cup Happy_j| = c > 0 \wedge Angry_j
       \neq \emptyset$ (the total number of angry and happy players cannot increase because no player leaves the $Sad$ set
       and if it were to be decreased, it would eventually reach 0). Since $Angry_j \neq \emptyset$, a player $v$ that will
       not pass her turn will eventually be chosen to play. According to algorithm \ref{transitivesteal}, $v$ will either
       deplete her incoming trust and enter the $Sad$ set (line~\ref{trstealtrueentersad}), which is contradicting $|Angry_j
       \cup Happy_j| = c$, or will steal enough value to enter the $Happy$ set, that is $v$ will achieve $Loss_{v, j} = 0$.
       Suppose that she has stolen $m$ players. They, in their turn, will steal total value at least equal to the value
       stolen by $v$ (since they cannot go sad, as explained above). However, this means that, since the total value being
       stolen will never be reduced and the turns this will happen are infinite, the players must steal an infinite amount of
       value, which is impossible because the direct trusts are finite in number and in value. More precisely, let $\forall j
       \in \mathbb{N}, DTr_j = \sum\limits_{w,w' \in \mathcal{V}}DTr_{w \rightarrow w', j}$. Also, without loss of
       generality, suppose that $\forall j \geq j_1, out_{A, j} = out_{A, j_1}$. \\ In $Turn_{j_1}$, $v$ steals $St_{j_1} =
       \sum\limits_{i=1}^{m}y_i$. Thus $DTr_{j_1} = DTr_{j_1-1} - St_{j_1}$. Eventually there is a turn $j_2$ when every
       player in $N^{-}(v)$ will have played. Then $S_{j_2} \leq DTr_{j_1} - St_{j_1} = DTr_{j_1-1} - 2St_{j_1}$, since all
       players in $N^{-}(v)$ follow the conservative strategy, except maybe for $A$, who will not have been stolen anything
       due to the supposition. \\
       Suppose that $\exists k > 1 : j_k > j_{k-1} > j_1 \Rightarrow DTr_{j_k} \leq DTr_{j_{k-1}} - St_{j_1}$. Then there
       exists a subset of the $Angry$ players, $S$, that have been stolen at least value $St_{j_1}$ in total between the
       turns $j_{k-1}$ and $j_k$, thus there exists a turn $j_{k+1}$ such that all players in $S$ will have played and thus
       $DTr_{j_{k+1}} \leq DTr_{j_k} - St_{j_1}$. We have proven by induction that $\forall n \in \mathbb{N}, \exists j_n \in
       \mathbb{N} : DTr_{j_n} \leq DTr_{j_1-1} - nSt_{j_1}$. However $DTr_{j_1-1}, St_{j_1} \in \mathbb{N}$, thus $\exists n'
       \in \mathbb{N} : n'St_{j_1} > DTr_{j_1-1} \Rightarrow DTr_{j_n'} < 0$. We have a contradiction because $\forall w,w'
       \in \mathcal{V}, \forall j \in \mathbb{N}, DTr_{w \rightarrow w', j} \geq 0$, thus eventually $Angry = \emptyset$ and
       everybody passes.
    \end{proof}

    \begin{theorem}[Saturation theorem] \ \\ 
       \label{saturation}
       Let $s$ source, $n = |N^{+}(s)|, x_i, i \in [n]$, flows to $s$'s neighbours as calculated by the
       maxFlow algorithm, $u_i'$ new direct trusts to the $n$ neighbours and $x_i'$ new flows to the neighbours
       as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. It holds that
       $\forall i \in [n], u_i' \leq x_i \Rightarrow x_i' = u_i'$.
    \end{theorem}
    \begin{proof} \ 
       $\forall i \in [n], x_i' > u_i'$ is impossible because a flow cannot be higher than its
       corresponding capacity. Thus $\forall i \in [n], x_i' \leq u_i'$. (1) \\
       In the initial configuration of $u_i$ and according to the flow problem setting, a combination of flows
       $y_i$ such that $\forall i \in [n], y_i = u_i'$ is a valid, albeit not necessarily maximum,
       configuration with a flow $\sum\limits_{i=1}^{n}y_i$. Suppose that $\exists k \in [n] : x_k'
       < u_k'$ as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. Then for the new
       maxFlow $F'$ it holds that $F' = \sum\limits_{i=1}^{n}x_i' < \sum\limits_{i=1}^{n}y_i$ since $x_k' < y_k$
       and (1) which is impossible because the configuration $\forall i \in [n], x_i' = y_i$ is valid since 
       $\forall i \in [n], y_i = u_i'$ and also has a higher flow, thus the maxFlow algorithm will
       prefer the configuration with the higher flow. Thus we deduce that $\forall i \in [n], x_i' = u_i'$.
    \end{proof}

    Let $G$ be a weighted directed graph. According to \cite{clrs} p. 709, if we consider each edge's capacity as its weight
    ($\forall e \in E(G), c_e = c(e)$), we say that a flow assignment $X = [x_{vw}]_{V(FG) \times V(FG)}$ with a source $A$
    and a sink $B$ is valid when:
    \begin{enumerate}
       \item \begin{equation}
             \label{flow1}
                \forall (v, w) \in E(FG), x_{vw} \leq c_{vw}
             \end{equation}
       \item \begin{equation}
             \label{flow2}
                \forall v \in V(FG) \setminus \{A,B\},
                \sum\limits_{w \in N^{+}(v)}x_{wv} = \sum\limits_{w \in N^{-}(v)}x_{vw}
             \end{equation}
%       \item $\sum\limits_{v \in N^{+}(A)}x_{Av} = \sum\limits_{v \in N^{-}(B)}x_{vB}$
    \end{enumerate}
    \begin{lemma}[MaxFlow $\rightarrow$ Transitive Steal execution] \ \\
       \label{maxflowgame}
       Let $\mathcal{G}_{j_0}$ be a game graph at a specific turn $j_0$, let $A, B \in V(\mathcal{G}_{j_0})$ and
       $maxFlow(A, B)$ the maximum flow from $A$ to $B$ executed on $\mathcal{G}_{j_0}$. There exists an execution of
       algorithm \ref{transitivesteal} and a turn $j_1 \in \mathbb{N}$ such that algorithm \ref{transitivesteal} has
       converged and $maxFlow(A, B) = Loss_{A, j_1}$.
    \end{lemma}
    \begin{proof} \ \\
       Without loss of generality, we suppose that the interesting turn is 0. In other words, $j_0 = 0$. Let $X =
       \{x_{vw}\}_{V(\mathcal{G}_0) \times V(\mathcal{G}_0)}$ be the flows returned by the execution of the $MaxFlow(A, B)$
       algorithm on $\mathcal{G}_0$. It is known that for any directed weighted graph $G$ there exists a $MaxFlow$ over $G$
       that is a DAG [citation needed]. We also know that we can apply the topological sort algorithm to any DAG and obtain a
       total ordering of its nodes with the following property: $\forall$ nodes $v, w$, it holds that
       $v < w \Rightarrow x_{wv} = 0$ [citation needed]. Put differently, there is no flow from larger to smaller nodes. We
       execute the topological sort on $X$ and obtain a total order of the nodes, such that $B$ is the maximum and
       $A$ is the minimum node. $B$ is maximum since it is the sink and thus has no outgoing flow to any node and $A$ is
       minimum since it is the source and thus has no incoming flow from any node. The desired execution of algorithm
       \ref{transitivesteal} will choose players following the total order, starting from player $B$. We observe that
       $\forall v \in \mathcal{G}_0, \sum\limits_{w \in V(\mathcal{G}_0)}x_{wv} = \sum\limits_{w \in V(\mathcal{G}_0)}x_{vw}
       \leq maxFlow(A, B) \leq in_{B, 0}$. Player $B$ will follow a modified evil strategy where she steals value equal to
       her total incoming flow, not her total incoming trust. We will show using strong induction that there exists a set of
       valid actions for each player according to their respective strategy such that at the end of each turn $j$ the
       corresponding player $v = Player(j)$ will have stolen value equal to her incoming flow,
       $\sum\limits_{w \in V(\mathcal{G}_0)}x_{wv}$.
       \begin{itemize}
          \item Base case: In turn 1, $B$ steals value equal to $\sum\limits_{w \in V(\mathcal{G}_0)}x_{wB}$, following the
          modified evil strategy. $$Turn_1 = \{Steal(x_{v_1B}, v_1), ..., Steal(x_{v_iB}, v_i), ...,Steal(x_{v_mB},
          v_m)\},$$ where $m = |N^{-}(B)_1|$ and $\forall i \in [m], v_i = N^{-}(B)_{1, i}$.
          \item Induction hypothesis: Let $k \in [j_1 - 2]$, where $j_1$ is the turn when $A$ is chosen to play. We suppose
          that $\forall j \in [k]$, there exists a valid set of actions, $Turn_j$, performed by $v = Player(j)$ such that $v$
          steals from each player $w$ value equal to $x_{wv}$. $$\forall j \in [k], Turn_j = \{Steal(x_{w_1v}, w_1), ...,
          Steal(x_{w_iv}, w_i), ..., Steal(x_{w_mv}, w_m)\},$$ where $m = |N^{-}(v)_j|$ and $\forall i \in [m], w_i =
          N^{-}(v)_{j, i}$.
          \item Induction step: Let $j = k + 1, v = Player(j)$. Since all the players that are greater than $v$ in the total
          order have already played and all of them have stolen value equal to their incoming flow, we deduce that $v$ has
          been stolen value equal to $\sum\limits_{w \in V(\mathcal{G}_0)}x_{vw}$. Since it is the first time $v$ plays,
          $\forall w \in N^{-}(v), DTr_{w \rightarrow v, j} = DTr_{w \rightarrow v, 0} \geq x_{wv}$, thus $v$ is able to
          choose the following turn: $$Turn_j = \{Steal(x_{w_1v}, w_1), ..., Steal(x_{w_iv}, w_i), ...,
          Steal(x_{w_mv}, w_m)\},$$ where $m = |N^{-}(v)_j|$ and $\forall i \in [m], w_i = N^{-}(v)_{j, i}$. Moreover, this
          turn satisfies the conservative strategy since $\sum\limits_{w \in V(\mathcal{G}_0)}x_{wv} = \sum\limits_{w \in
          V(\mathcal{G}_0)}x_{vw}$. Thus $Turn_j$ is a valid turn for the conservative player $v$.
       \end{itemize}
       We have proven that in the end of turn $j_1 - 1$, player $B$ and all the conservative players will have stolen value
       exactly equal to their total incoming flow, thus $A$ will have been stolen value equal to her outgoing flow, which is
       $maxFlow(A, B)$. Thus we have proven that there exists a valid execution of algorithm \ref{transitivesteal} where
       $Loss_{A, j_1} = maxFlow(A, B)$.
    \end{proof}
    The fact that $B$ follows the modified evil strategy in the previous proof only strengthens our result, since we can see
    that $A$ can lose value equal to $maxFlow(A, B)$ even if $B$ chooses a more moderate strategy than the evil one.
    \begin{lemma}[Transitive Steal execution $\rightarrow$ flow] \ \\
       \label{gameflow}
       Let $\mathcal{G}_0$ be a directed graph and $A, B \in V(\mathcal{G}_0)$ where $Strategy(A) = Idle \wedge Strategy(B) =
       Evil$. Let also $\mathcal{H}$ be a history corresponding to an execution of algorithm \ref{transitivesteal} on the
       graph $\mathcal{G}_0$ and $j_1$ a turn when algorithm \ref{transitivesteal} has converged. There exists a valid flow
       $X = \{x_{wv}\}_{V(\mathcal{G}_0) \times V(\mathcal{G}_0)}$ on $\mathcal{G}_0$ such that
       $\sum\limits_{v \in V(\mathcal{G}_0)}x_{Av} = Loss_{A, j_1}$.
    \end{lemma}
    \begin{proof}
       Let $\mathcal{G}'$ be a directed weighted graph based on $\mathcal{G}_0$ with an auxiliary source. $\mathcal{G}'$ is
       defined as follows:
       \begin{itemize}
          \item $V(\mathcal{G}') = V(\mathcal{G}_0) \cup \{T\}$
          \item $E(\mathcal{G}') = E(\mathcal{G}_0) \cup \{(T, A)\} \cup \{(T, v) : v \in Sad_{j_1}\}$
          \item $\forall (v, w) \in E(\mathcal{G}_0), c'_{vw} = DTr_{v \rightarrow w, 0} - DTr_{v \rightarrow w, j_1}$
          \item $\forall v \in Sad_{j_1}, c'_{Tv} = c'_{TA} = \infty$
          \item $\forall v \in V(\mathcal{G}_0), c'_{vT} = 0$
       \end{itemize}
------------MAY BE UNNECESSARY--------- \\
       We can safely suppose that $\forall v \in V(\mathcal{G}_0), \forall j \in \mathbb{N}, DTr_{B \rightarrow v, j} = 0$,
       that can be equivalently seen as $\forall j \in \mathbb{N}, N^{+}(B)_j = \emptyset$, or even $\forall j \in
       \mathbb{N}, out_{B, j} = 0$. We can maintain such a supposition since the other players do not modify $B$'s outgoing
       trust or take any modification of $B$'s outgoing trust into consideration. We further observe that $Strategy(A) =
       Idle$, that nobody reduces her outgoing trust to $A$ and that nobody takes a modification of $A$'s incoming trust into
       consideration, thus we can again suppose that $\forall j \in \mathbb{N}, N^{-}(A)_j = \emptyset \Leftrightarrow
       \forall j \in \mathbb{N}, in_{A, j} = 0$. \\
------------MAY BE UNNECESSARY--------- \\
       Next we try to calculate $MaxFlow(T, B) = X'$ on graph $\mathcal{G}'$. We observe that a flow in which it holds that
       $\forall v, w \in V(\mathcal{G}_0), x'_{vw} = c'_{vw}$ can be valid for the following reasons:
       \begin{itemize}
          \item $c'_{vw} \leq c'_{vw}$ (\ref{flow1})
          \item Let $v \in V(\mathcal{G}_0) \setminus (Sad_{j_1} \cup \{A, B\})$. According to the conservative strategy and
          since $v \notin Sad_{j_1}, out_{v, 0} - out_{v, j_1} = in_{v, 0} - in_{v, j_1}$. Also, according to the definition
          of $\mathcal{G}', \sum\limits_{w \in V(\mathcal{G}')}c'_{vw} = out_{v, 0} - out_{v, j_1} \wedge \sum\limits_{w \in
          V(\mathcal{G}')}c'_{wv} = in_{v, 0} - in_{v, j_1}$. Combining these observations, we have that $\sum\limits_{w \in
          V(\mathcal{G}')}c'_{vw} = \sum\limits_{w \in V(\mathcal{G}')}c'_{wv}$. (\ref{flow2})
          \item Let $v \in Sad_{j_1}$. Since $v$ is sad, we know that $out_{v, 0} - out_{v, j_1} > in_{v, 0} - in_{v, j_1}$.
          According to the definition of $\mathcal{G}', \sum\limits_{w \in V(\mathcal{G}')}c'_{vw} = out_{v, 0} -
          out_{v, j_1}$ and, since $c'_{Tv} = \infty$, we can set $x'_{Tv} = (out_{v, 0} - out_{v, j_1}) - (in_{v, 0} -
          in_{v, j_1})$. In this way, we have $\sum\limits_{w \in V(\mathcal{G}')}x'_{vw} = out_{v, 0} - out_{v, j_1},
          \sum\limits_{w \in V(\mathcal{G}')}x'_{wv} = \sum\limits_{w \in V(\mathcal{G}') \setminus \{T\}}c'_{wv} + x'_{Tv} =
          in_{v, 0} - in_{v, j_1} + (out_{v, 0} - out_{v, j_1}) - (in_{v, 0} - in_{v, j_1}) = out_{v, 0} - out_{v, j_1}
          \Rightarrow \sum\limits_{w \in V(\mathcal{G}')}x'_{vw} = \sum\limits_{w \in V(\mathcal{G}')}x'_{wv}$. (\ref{flow2})
          \item We set $x'_{TA} = \sum\limits_{v \in V(\mathcal{G}')}x'_{Av} \Rightarrow \sum\limits_{v \in
          V(\mathcal{G}')}x'_{Av} = \sum\limits_{v \in V(\mathcal{G}')}x'_{vA}$. (\ref{flow2})
       \end{itemize}
       We saw that for all intermediate nodes, the necessary properties for a flow to be valid hold and thus $X'$ is a valid
       flow for $\mathcal{G}_0$. $\sum\limits_{v \in V(\mathcal{G}')}x'_{Av} = \sum\limits_{v \in V(\mathcal{G}')}c'_{Av} =
       out_{A, 0} - out_{A, j_1} = Loss_{A, j_1}$. Moreover, this flow is equal to $maxFlow(T, B)$ because all incoming flows
       to $B$ are saturated.
%       There obviously [citation needed] exists a subflow from $A$ to $B$ equal to $Loss_{A, j_1}$. \\
       We define another graph, $\mathcal{G}''$, based on $\mathcal{G}'$.
       \begin{itemize}
          \item $V(\mathcal{G}'') = V(\mathcal{G}')$
          \item $E(\mathcal{G}'') = E(\mathcal{G}') \setminus \{(T, v) : v \in Sad_j\}$ or equivalently $E_(\mathcal{G}'') =
          E(\mathcal{G}_0) \cup \{(T, A)\}$
          \item $\forall e \in E(\mathcal{G}''), c''_e = c'_e$
       \end{itemize}
       If we execute the algorithm $MaxFlow(T, B)$ on the graph $\mathcal{G}''$, we will obtain a flow $X''$ in which
       $\sum\limits_{v \in V(\mathcal{G}'')}x''_{Tv} = x''_{TA} = \sum\limits_{v \in V(\mathcal{G}'')}x''_{Av}$. The outgoing
       flow from $A$ in $X''$ will remain the same as in $X'$ for two reasons:
       \begin{itemize}
          \item $\sum\limits_{v \in V(\mathcal{G}'')}c''_{Av} = \sum\limits_{v \in V(\mathcal{G}')}c'_{Av} = \sum\limits_{v
          \in V(\mathcal{G}')}x'_{Av} \wedge \sum\limits_{v \in V(\mathcal{G}'')}c''_{Av} \geq \sum\limits_{v \in
          V(\mathcal{G}'')}x''_{Av} \Rightarrow \sum\limits_{v \in V(\mathcal{G}')}x'_{Av} \geq \sum\limits_{v \in
          V(\mathcal{G}'')}x''_{Av}$
          \item No capacity reachable by $A$ is modified and $T$ has no incoming flow, thus $\sum\limits_{v \in
          V(\mathcal{G}'')}x''_{Av} \geq \sum\limits_{v \in V(\mathcal{G}')}x'_{Av}$ [citation needed]
       \end{itemize}
       The flow $X^A = X'' \setminus \{(T, A)\}$ is a possible output of $MaxFlow(A, B)$. This holds for the following
       reasons:
       \begin{itemize}
          \item If we suppose $maxFlow(A, B) > \sum\limits_{v \in V(\mathcal{G}'')}x''_{Av}$, then we can choose $X^T$ to be
          $X^A \cup \{(T, A)\} \wedge \forall v, w \in V(\mathcal{G}''), x^T_{vw} = x^A_{vw}$, thus $x^T_{TA} =
          \sum\limits_{v \in V(\mathcal{G}'')}x^A_{Av}$. Since $\sum\limits_{v \in V(\mathcal{G}'')}x^A_{Av} =
          maxFlow(A, B)$, we see that $\sum\limits_{v \in V(\mathcal{G}'')}x^T_{Tv} = x^T_{TA} > x''_{TA}$, thus $X''$ is not
          $MaxFlow(T, B)$, which is a contradiction.
          \item If we suppose that $maxFlow(A, B) = f < \sum\limits_{v \in V(\mathcal{G}'')}x''_{Av}$, we can likewise choose
          ${X^A}'$ such that $\forall v, w \in V(\mathcal{G}'') \setminus \{T\}, {x^A}'_{vw} = x''_{vw}$, thus
          $\sum\limits_{v \in V(\mathcal{G}'') \setminus \{T\}}{x^A}'_{Av} = \sum\limits_{v \in V(\mathcal{G}'')}x''_{Av}$.
          We deduce that $\sum\limits_{v \in V(\mathcal{G}'') \setminus \{T\}}{x^A}'_{Av} > f$, which is a contradiction.
       \end{itemize}
       Thus there exists a valid flow for each execution of algorithm \ref{transitivesteal}, which is the flow $X^A$.
    \end{proof}
    \begin{theorem}[Trust flow theorem - TOCHECK] \ \\
       \label{trustflow}
       Let $\mathcal{G}$ be a game graph at a specific turn and $A, B \in V(\mathcal{G})$. It holds that
       $Tr_{A \rightarrow B} = maxFlow(A, B)$
    \end{theorem}
    \begin{proof} \ \\
       Without loss of generality, we can suppose that the turn in which we are interested is 0 ($\mathcal{G} =
       \mathcal{G}_0$). First we will show that the $MaxFlow$ can be a result of a valid execution of algorithm
       \ref{transitivesteal} and afterwards we will show that each valid execution of algorithm \ref{transitivesteal}
       corresponds to a valid flow from $A$ to $B$. Thus we will have proven that $Tr_{A \rightarrow B} = maxFlow(A, B)$.
       \begin{itemize}
%          \item We will first show that there exists an execution of algorithm \ref{transitivesteal} such that $Loss_A =
%          maxFlow(A, B)$. Let $X$ be the flows as returned by an execution of the $MaxFlow(A, B)$ algorithm on $\mathcal{G}$.
%          It is known that all flows are DAGs [citation needed] and that all DAGs are a partial order of their nodes based on
%          the partial ordering $x_{vw} \leq 0 \Rightarrow v < w$ [citation needed]. From this partial order, we can create a
%          total order with an algorithm such as topoSort \cite{toposort}. The maximum element of the total order is a node
%          that does not have any outgoing flow. Removing any node from a DAG cannot create a cycle, thus the graph that
%          remains after removing a node from a DAG is also a DAG, thus it has a total order as well, which can be chosen to
%          be the same total order as before removing the node, except for the removed node. If the removed node was maximum
%          or minimum, the new total order is obvious. We will prove our claim using induction. \\
%          \begin{itemize}
%             \item Player $B$ is the maximum node in turn 0 because she is the sink of the MaxFlow algorithm, thus she is the
%             first to be chosen to play and steals all her incoming and outgoing trust. $\forall v \in N^{-}(B)_0, x_{vB}
%             \leq DTr_{v \rightarrow B, 0}$ and $\sum\limits_{v \in N^{-}(B)_0}x_{vB} = maxFlow(A, B)$. The graph
%             $\mathcal{G}_1 = \mathcal{G}_0 \setminus \{B\}$ is also a DAG and corresponds to the previous total order if we
%             remove the maximum element, $B$.
%             \item Suppose that $\forall j \in [k], k > 0$, the player $v$ corresponding to the maximum element is chosen to
%             play for the first time, that $\forall w \in N^{-}(v)_{j-1} (= N^{-}(v)_0), x_{wv} \leq y$ where $Steal(y,w) \in
%             Turn_j \wedge \sum\limits_{w \in N^{-}(v)_0}x_{wv} = \sum\limits_{w \in N^{+}(v)_0}x_{vw}$.
%             \item For $j = k+1$, $Player(k+1) = v'$ corresponds to the maximum element of the previous total order with the
%             element $v$ removed and it is the first time player $v'$ plays, since $v > v'$ in all previous steps thus $v'$
%             was not maximum. It also holds that $\forall w \in N^{-}(v')_0, x_{wv'} \leq DTr_{w \rightarrow v', 0}$ since
%             the $x_{wv'}$ are chosen by the maxFlow algorithm with corresponding capacities the direct trusts and, since
%             $\sum\limits_{w \in N^{-}(v')_0}x_{wv'} = \sum\limits_{w \in N^{+}(v')_0}x_{v'w}$ and player $v'$ has already
%             been stolen value equal to $\sum\limits_{w \in N^{+}(v')_0}x_{v'w}$ (since she has no outgoing flow in turn
%             $j$), player $v'$ can choose to steal from each player $w \in N^{-}(v')_0$ value at least equal to $x_{wv'}$
%             without violating the conservative strategy.
%          \end{itemize}
%          We have proven using induction that if the algorithm chooses only maximum nodes, after exactly $|V(\mathcal{G}_0)|-
%          1$ turns (we do not count idle player $A$) every player except for $A$ will have stolen at least value equal to the
%          flow passing through them and player $A$ will have been stolen value exactly equal to $maxFlow(A, B) \Rightarrow
%          Loss_A = maxFlow(A, B)$.
          \item We will now show that for any valid execution of algorithm \ref{transitivesteal} there exists at least one
          valid flow from $A$ to $B$, such that $Loss_A = \sum\limits_{v \in N^{+}(A)_0}x_{Av}$. Let $j$ be a turn where
          \ref{transitivesteal} has converged ($j$ exists, according to theorem \ref{convergence}). Then $Loss_{A, j} =
          out_{A, 0} - out_{A, j}$. We create a new graph $\mathcal{G}'$ such that $V(\mathcal{G}') = V(\mathcal{G}) \cup
          \{T\}, E(\mathcal{G}') = E(\mathcal{G}) \cup \{(T, v) : v \in Sad_j\} \cup (T, A), \forall (v, w) \in E(\mathcal{G}),
          c'_{vw} = DTr_{v \rightarrow w, 0} - DTr_{v \rightarrow w, j}, \forall v \in Sad_j, c'_{Tv} = c'_{TA} = \infty$
          ($T$ is an auxiliary source that trusts infinitely $A$ and all the $Sad$ nodes). We execute the $MaxFlow(T, B)$
          algorithm on $\mathcal{G}'$ and we get a flow $X' : \forall v,w \in V(\mathcal{G}), x'_{vw} = c'_{vw}$ (all the
          edges, except for the auxiliary ones, saturated). Thus $\sum\limits_{v \in N^{+}(A)_0}x'_{Av} = Loss_{A, j}$.
          If we create a new graph $\mathcal{G}''$ with $V(\mathcal{G}'') = V(\mathcal{G}'), E(\mathcal{G}'') =
          E(\mathcal{G}'), \forall v \in Sad_j, c''_{Tv} = 0, c''_{TA} = \infty, \forall v,w \in V(\mathcal{G}), c''_{vw} =
          c_{vw}$ (the auxiliary node trusts only $A$) and execute the $MaxFlow(T, B) = X''$ algorithm on $\mathcal{G}''$,
          $\sum\limits_{v \in N^{+}(A)_0}x''_{Av} = \sum\limits_{v \in N^{+}(A)_0}x'_{Av}$ (the outgoing flow from
          $A$ will remain the same as in $\mathcal{G}'$) since no capacity accesible from $A$ has been modified (the only
          changed capacities are those that begin from $T$ and there is no incoming flow to $T$) thus $\sum\limits_{v \in
          N^{+}(A)_0}x''_{Av} \geq \sum\limits_{v \in N^{+}(A)_0}x'_{Av}$ and $\sum\limits_{v \in N^{+}(A)_0}x'_{Av} =
          \sum\limits_{v \in N^{+}(A)_0}c'_{Av} = \sum\limits_{v \in N^{+}(A)_0}c''_{Av}$ (the outgoing edges from $A$ were
          already saturated) thus $\sum\limits_{v \in N^{+}(A)_0}x''_{Av} \leq \sum\limits_{v \in N^{+}(A)_0}x'_{Av}$. Thus
          the resulting flow is equal to $Loss_{A, j}$, or $\sum\limits_{v \in N^{+}(A)_0}x''_{Av} = \sum\limits_{v \in
          N^{+}(A)_0}c'_{Av} = Loss_{A, j}$.
       \end{itemize}
       We finally conclude that $Tr_{A \rightarrow B} = MaxFlow(A, B)$.
    \end{proof}
%          \begin{itemize}
%             \item The flow $X$ is obviously valid for the initial graph because $\forall (v,w) \in E(FG), c(v,w) = DTr_{v
%             \rightarrow w, 0} \geq DTr_{v \rightarrow w, 0} - DTr_{v \rightarrow w, j} = c'(v,w) \geq x_{vw}$ and it
%             already holds that $\forall v \in V(FG'), \sum\limits_{w \in N^{-}(v)}x'_{wv} = \sum\limits_{w \in N^{+}(v)}
%             x'_{vw}$, thus it also holds for the flows of $X$.
%             \item We can easily see that $Loss_{A,j} \geq \sum\limits_{v \in N{+}(A)}x_{Av}$ because $Loss_{A,j} =
%             out_{A,0} - out_{A,j} = \sum\limits_{v \in N^{+}(A)}c'(A,v)$. To show that $Loss_{A,j} \leq
%             \sum\limits_{v \in N{+}(A)}x_{Av}$, we first suppose that $Loss_{A,j} > \sum\limits_{v \in N{+}(A)}x_{Av}$. We
%             will now prove that there exists a residual path from $A$ to $B$. $Loss_{A,j} = \sum\limits_{v \in N^{+}(A)}
%             (DTr_{A \rightarrow v, 0} - DTr_{A \rightarrow v, j}) = \sum\limits_{v \in N^{+}(A)}c_{Av}$. From the
%             supposition we can see that $\sum\limits_{v \in N^{+}(A)}c_{Av} > \sum\limits_{v \in N^{+}(A)}x_{Av}
%             \Rightarrow \exists v \in N^{+}(A) : c_{Av} > x_{Av}$. \\
%             Since $\forall v \in V(FG) \setminus \{A,B\}, \sum\limits_{w \in N^{-}(v)}c_{wv} \overset{conservative}{=}
%             \sum\limits_{w \in N^{+}(v)}c_{vw} \wedge \sum\limits_{w \in N^{-}(v)}x_{wv} \overset{flow}{=}
%             \sum\limits_{w \in N^{+}(v)}x_{vw}$, it holds that $\forall v \in V(FG) \setminus \{A,B\}, \sum\limits_{w \in
%             N^{-}(v)}(c_{wv} - x_{wv}) = \sum\limits_{w \in N^{+}(v)}(c_{vw} - x_{vw})$. \\
%             We will now show that $\forall v \in V(FG) \setminus
%             \{A,B\}, (\exists w \in V(FG) : c_{wv} > x_{wv} \Rightarrow \exists u \in V(FG) : c_{vu} > x_{vu})$. Suppose
%             that the previous statement is false. Then it would hold that $\exists v \in V(FG) \setminus \{A,B\} :
%             (\exists w \in V(FG) : c_{wv} > x_{wv} \wedge \forall u \in V(FG), c_{vu} = x_{vu})$ (1). But then we have
%             $\sum\limits_{w \in V(FG)}c_{wv} \overset{(1)}{>} \sum\limits_{w \in V(FG)}x_{wv} \overset{flow}{=}
%             \sum\limits_{w \in V(FG)}x_{vw} \overset{(1)}{=} \sum\limits_{w \in V(FG)}c_{vw} \overset{conservative}{=}
%             \sum\limits_{w \in V(FG)}c_{wv} \Rightarrow \sum\limits_{w \in V(FG)}c_{wv} > \sum\limits_{w \in V(FG)}c_{wv}$
%             which is a contradiction. Thus we showed that $\forall v \in V(FG) \setminus \{A,B\}, (\exists w \in V(FG) :
%             c_{wv} > x_{wv} \Rightarrow \exists u \in V(FG) : c_{vu} > x_{vu})$. \\
%             The flow graph that resulted from
%             $MaxFlow(A, B)$ is a DAG, thus there exists a corresponding total ordering, as we saw before.
%             Obviously $A = v_0$ and $B = v_{|V(FG)|}$. When an element $v_k$ is in the $k$-th position in this total
%             ordering, it has incoming flow only from smaller elements and outgoing flow only to bigger elements, that is
%             $\forall l < k, x_{kl} = 0 \wedge \forall m > k, x_{mk} = 0$.
%             Thus the previous result can be rewritten this way: $\forall k \in [|V(FG)|],
%             (\exists l < k : c_{v_lv_k} > x_{v_lv_k} \Rightarrow \exists m > k : c_{v_kv_m} > x_{v_kv_m})$.
%             Thus, the supposition $Loss_{A, j} > \sum\limits_{v \in N^{+}(A)}x_{Av}$ combined with the previous result shows
%             that there exists a residual path from $A$ to $B$ since we can start from $A$ and find a series of sequential
%             edges that all have flows smaller than the corresponding capacities and eventually reach $B$ in at most
%             $|E(FG)|$ steps, thus $X'$ is not a maximum flow, which is a contradiction. Thus $Loss_{A,j} \leq
%             \sum\limits_{v \in N{+}(A)}x_{Av}$ and, since also $Loss_{A,j} \geq \sum\limits_{v \in N{+}(A)}x_{Av}$, we
%             deduce that $Loss_{A,j} = \sum\limits_{v \in N{+}(A)}x_{Av}$.
%          \end{itemize}
%2nd bullet
%          \item We will now show that for any valid execution of algorithm \ref{transitivesteal} there exists at least one
%          valid flow from $A$ to $B$, $X$, such that $Loss_A = \sum\limits_{v \in N^{+}(A)}x_{Av}$. Let $j$ be a turn where
%          \ref{transitivesteal} has converged ($j$ exists, according to theorem \ref{convergence}). Then $Loss_{A, j} =
%          out_{A, 0} - out_{A, j}$. Let $\forall v \in N^{+}(A)_0, x_{Av} = DTr_{A \rightarrow v, 0} - DTr_{A \rightarrow
%          v, j}$. For any conservative player $v \in N^{+}(A)_0$, let $\forall w \in N^{+}(v)_0, x_{vw} \leq DTr_{v
%          \rightarrow w, 0} - DTr_{v \rightarrow w, j}, \sum\limits_{w \in N^{+}(A)_0}x_{vw} = x_{Av}$. This is possible
%          because $v$ is conservative, thus the value she stole from $A$ must have been stolen previously from her. More
%          generally, $\forall v \in \mathcal{V}_0 \setminus \{A,B\}, \forall w \in N^{+}(v)_0, x_{vw} \leq
%          DTr_{v \rightarrow w, 0} - DTr_{v \rightarrow w, j}, \sum\limits_{w \in N^{+}(v)_0}x_{vw} = \sum\limits_{w \in
%          N^{-}(v)_0}x_{wv}$. Since the graph we build is a DAG in every step, which corresponds to a partial order, there
%          always exists a total order that we can get using an algorithm such as topoSort [citation needed]. Thus, by
%          choosing to calculate the outgoing flows only of the minimum element of this total order, it is possible to create
%          a valid flow network from $A$ to $B$ in exactly $|V(FG)| - 1$ iterations of the above steps.
%OLD
%          \item The flow to $A$ is the flow that results from the following process: After the execution of
%          \ref{transitivesteal}, for each sad player iteratively replenish the $DTr$ stolen from the sad player by the one
%          that stole from her (if multiple players stole from the sad player, then replenish all the stolen $DTr$). Repeat
%          the process until the evil player replenishes the initially stolen $DTr$. This is always possible because if there
%          is no player who stole from each one who is replenished, then the $Steal()$ she did in the first place would not be
%          according to the conservative strategy. Also this process will end with the evil player replenishing $DTr$ equal
%          to the sum of $DTr$ that was stolen from sad players because the conservative players cannot avoid replenishing,
%          or else they do not follow the conservative strategy. The $DTr$ stolen from $A$ will not be replenished, since
%          the player(s) that have stolen from $A$ will not replenish the stolen value and, inductively, this value will not
%          be replenished. Thus $A$ will have been stolen the exact same value that the modified evil player has stolen,
%          $\forall w,v \in V(FG), DTr_{v \rightarrow w} \geq x_{vw}$ (1st requirement for flows) and there would be no node
%          that gets more flow than it pushes, except for $A$ and $B$ (2nd requirement for flows), thus it is a valid flow.
%          \item Let $X$ be the flows as returned by an execution of the $maxFlow$ algorithm. The evil player can steal
%          the values denoted by $X$ and every other player can steal exactly as much as the $X$ flows denote, since they
%          have the 1st property and thus are stealable in any strategy and also hold the 2nd property, thus they comply with
%          the conservative strategy. More concretely, $\forall v,w \in V(FG), DTr_{v \rightarrow w}' = x_{vw}$. Then the two
%          properties of flows hold:
%          \begin{itemize}
%             \item $\forall v,w \in V(FG),x_{vw} \leq DTr_{v \rightarrow w}$ and thus any set of strategies that include only
%             $Steal()$ actions such that $\sum\limits_{y : Steal(y,w) \in Turn_j, Player(j) = v}y = DTr_{v \rightarrow w} -
%             x_{vw}$ is feasible.
%             \item $\forall v \in V(FG) \setminus \{A,B\}, \sum\limits_{w \in N^{+}(v)}x_{wv} =
%             \sum\limits_{w \in N^{-}(v)}x_{vw}$ thus $\forall v \in V(FG) \setminus \{A,B\}, Strategy(v) = Conservative$.
%          \end{itemize}
%             
%       \end{itemize}
%       Thus the maximum value $A$ can lose if $B$ is evil is $Tr_{A \rightarrow B} = maxFlow(A, B)$.
%\ \\ OLDER
%       \begin{enumerate}
%	   \item We will show that $Tr_{A \rightarrow B} \leq MaxFlow(A, B)$.
%          We know that $MaxFlow(A, B) = MinCut_{A \rightarrow B}$. We will show that, if everybody except
%          A and B follows the conservative strategy,  $Tr_{A \rightarrow B} \leq MinCut_{A \rightarrow B}$. Suppose that in
%          round $i$ all the members of the MinCut, $P$, have stolen the maximum value they can from members that belong
%          in the MaxFlow graph and nobody in the partition in which $A$ belongs has stolen yet any value. Let the total
%          stolen value from the MinCut members be $St$. It is obvious that $St_i \leq MinCut_{A \rightarrow B}$, because
%          otherwise there would exist $u \in P$ that doesn't follow the conservative strategy, since they stole more than they
%          were stolen from. The same argument holds for any round $i' > i$ because in each round an conservative player can
%          steal only up to the value she has been stolen. It is also impossible that the $St$ increase further due to
%          stolen value from members of the partition of $B$ since members of $P$ disconnect the two partitions and have
%          already played their turns, thus $\forall i' > i, St_{i'} \leq St_i$. There exists a round, $k$, when all the
%          conservative players stop stealing, so in the worst case $A$ will have been stolen
%          $Tr_{A \rightarrow B} = St_k \leq MinCut_{A \rightarrow B} = MaxFlow(A, B)$.
%          \item We can see that $Tr_{A \rightarrow B} \geq MaxFlow(A, B)$ because the strategy where each
%          one of the non-idle players steals value equal to the incoming flows from their respective friends is a valid
%          strategy that does not contradict with the conservative strategy, since for every conservative player $w$ it holds that
%          $\sum\limits_{v \in N^{-}(w)}x_{vw} = \sum\limits_{v \in N^{+}(w)}x_{wv}$ and according to the strategy each
%          conservative player will have been stolen value equal to $\sum\limits_{v \in N^{+}(w)}x_{wv}$. More concretely,
%          let $Player(j) = B$ and $Player(j+d) = C :$
%       \end{enumerate}
%       Combining the two results, we see that $Tr_{A \rightarrow B} = MaxFlow(A, B)$.
%        OLD PROOF START
%        \begin{enumerate}
%           \item $Tr_{A \rightarrow B} \geq MaxFlow(A, B)$ because by the definition of $Tr_{A \rightarrow B}$,
%           B leaves taking with him all the incoming trust, so there is no trust flowing towards him after leaving.
%           $Tr_{A \rightarrow B} < MaxFlow(A, B)$ would imply that after B left, there would still remain trust
%           flowing from A to B.
%           \item $Tr_{A \rightarrow B} \leq MaxFlow(A, B)$ \\
%           Suppose that $Tr_{A \rightarrow B} > MaxFlow(A, B)$ (1). Then, using the min cut - max flow theorem we
%           see that there is a set of capacities $U= \{u_1,...,u_n\}$ with flows $X = \{x_1,...,x_n\}$ such that
%           $\sum\limits_{i=1}^{n}{x_i} = MaxFlow(A, B)$ and, if severed $(\forall i \in [n] \: u_i' = 0)$
%           the flow from A to B would be $0$, or, put differently, there would be no directed trust path from A to B. No
%           strategy followed by B could reduce the value of A, so our supposition (1) cannot be true.
%        \end{enumerate}
%        OLD PROOF END

    \begin{theorem}[Conservative world theorem] \ \\
       \label{conservativeworld}
       If everybody follows the conservative strategy, nobody steals any amount from anybody.
    \end{theorem}
    \begin{proof} \ \\
       Suppose that there exists a subseries of History, $(Turn_{j_k})$, where $Turn_{j_k} = \{Steal(y_1,B_1),...,
       Steal(y_m,B_m)\}$. This subseries must have an initial element, $Turn_{j_1}$. However, $Player(j_1)$ follows the conservative
       strategy, thus somebody must have stolen from her as well, so $Player(j_1)$ cannot be the initial element. We have a
       contradiction, thus there cannot exist a series of stealing actions when everybody is conservative.
    \end{proof}

    \begin{theorem}[Trust transfer theorem (flow terminology)] \ \\
       \label{trusttransfer}
       Let $s$ source, $t$ sink, $n = N^{+}(s)$ \\
       $X = \{x_1, ..., x_n\}$ outgoing flows from $s$, \\
       $U = \{u_1, ..., u_n\}$ outgoing capacities from $s$, \\
       $V$ the value to be transferred. \\
       Nodes apart from $s$, $t$ follow the conservative strategy. \\
       Obviously $maxFlow = F = \sum\limits_{i=1}^{n}{x_i}$.
       {\em \begin{lstlisting}
            /                      ....                     \
           / x_s1/u_s1                         x_1t/u_1t     \
          /                                                   \
         /                                                     \
        / x_s2/u_s2                               x_2t/u_2t     \
       s-------------              ....          ------------t
        \      .                                           .    /
         \     .                                           .   /
          \    .                                           .  /
           \ x_sn/u_sn             ....        x_mt/u_mt     /
            \                                               /
       \end{lstlisting}}
       We create a new graph where
       \begin{enumerate}
         \item  $\sum\limits_{i=1}^{n}{u_i'} = F - V$
         \item $\forall i \in [n] \: u_i' \leq x_i$
       \end{enumerate}
 
       It holds that $maxFlow' = F' = F - V$.
    \end{theorem}
    \begin{proof} \
        From theorem \ref{saturation} we can see that $x_i' = u_i'$. It holds that $F' = \sum\limits_{i=1}^nx_i' =
        \sum\limits_{i=1}^nu_i' = F - V$.
    \end{proof}

%    \begin{corollary}[Requirement for $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V$, $u_{s, i}' \leq x_{s, i}$] \ \\
%       In the setting of \ref{trusttransfer}, it is impossible to have $maxFlow' = F - V$ if
%       $\sum\limits_{i=1}^{n}{u_{s, i}'} > F - V \wedge \forall i \in [n],u_{s, i}' \leq x_{s, i}$.
%    \end{corollary}
%    \begin{proof}
%       Due to \ref{trusttransfer}, $maxFlow' = F - V$ if $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V
%       \wedge \forall i \in [n], u_{s, i}' \leq x_{s, i}$. If we create new capacities such that
%       $\forall i \in [n], u_{s,i}'' \leq x_{s,i}$, then obviously $maxFlow'' = \sum\limits_{i=1}^{n}{u_{s,i}''}$. If
%       additionally $\sum\limits_{i=1}^{n}{u_{s,i}''} > F - V$, then $maxFlow'' > F - V$.
%    \end{proof}

    \begin{lemma}[Flow limit lemma] \ \\
       \label{flowlimit}
       It is impossible for the outgoing flow $x_i$ from $A$ to an out neighbour of $A$ to be greater than
       $F_{A_i \rightarrow B}$. More formally, $x_i \leq F_{A_i \rightarrow B}$.
    \end{lemma}
    \begin{proof}
       Suppose a configuration where $\exists i : x_i > F_{A_i \rightarrow B}$. If we reduce the capacities $u_k, k \neq i$
       the flow that passes from $i$ in no case has to be reduced. Thus we can set $\forall k \neq i, u_k' = 0$ and $u_i' =
       u_i$. Then $\forall k \neq i,x_k' = 0, x_i' = x_i$ is a valid configuration and thus by definition $F_{A_i \rightarrow
       B} = x_i' = x_i > F_{A_i \rightarrow B}$, which is a contradiction. Thus $\forall i \in [|N^{+}(A)|], x_i \leq
       F_{A_i \rightarrow B}$.
    \end{proof}

    \begin{theorem}[Trust-saving Theorem] \ \\
       \label{trustsave}
       A configuration $U' : u_i' = F_{A_i \rightarrow B}$ for some $i \in [|N^{+}(A)|]$ can yield the same $maxFlow$ with a
       configuration $U'' : u_i'' = u_i, \forall k \in [|N^{+}(A)|], k \neq i, u_k'' = u_k'$.
    \end{theorem}
    \begin{proof}
       We know that $x_i \leq F_{A_i \rightarrow B}$ (lemma \ref{flowlimit}), thus we can see that any increase in $u_i'$
       beyond $F_{A_i \rightarrow B}$ will not influence $x_i$ and subsequently will not incur any change on the rest of the
       flows.
    \end{proof}

    \begin{theorem}[Invariable trust reduction with naive algorithms] \ \\
       \label{invariability}
       Let $A$ source, $n = |N^{+}(A)|$ and $u_i'$ new direct trusts. If $\forall i \in [n],u_i' \leq x_i$,
       Trust Reduction $||\delta_i||_1$ is independent of $x_i, u_i' \:\: \forall$ valid configurations of $x_i$
    \end{theorem}
    \begin{proof} 
       Since $\forall i \in [n],u_i' \leq x_i$ it is (according to \ref{saturation}) $x_i' = u_i'$, thus
       $\delta_i = u_i - x_i'$. We know that $\sum\limits_{i=1}^{n}x_i' = F - V$, so we have $||\delta_i||_1 =
       \sum\limits_{i=1}^{n}\delta_i = \sum\limits_{i=1}^{n}(u_i - x_i') = \sum\limits_{i=1}^{n}u_i - F + V$ independent
       from $x_i', u_i'$
    \end{proof}

    \begin{theorem}[Dependence impossibility theorem] \ \\
       \label{independence}
       ${\partial x_k \over \partial x_i} = 0$ with $x_i$ the flow from MaxFlow $\Rightarrow
         \forall x_i' \leq x_i, {\partial x_k \over \partial x_i} = 0$ ceteris paribus
    \end{theorem}
    \begin{proof}
       TODO
    \end{proof}
    Note: The maxFlow is the same in the following two cases: When a player chooses the evil strategy and when the same
    player chooses a variation of the evil strategy where she does not nullify her outgoing direct trust.

    \begin{theorem}[Trust to multiple players] \ \\
       \label{trustmany}
       Let $S \subset \mathcal{V}, T$ auxiliary player such that $\forall B \in S, DTr_{B \rightarrow T} = \infty$.
       It holds that $\forall A \in \mathcal{V} \setminus S, Tr_{A \rightarrow S} = maxFlow(A, T)$.
    \end{theorem}       
    \begin{proof}
       If $T$ chooses the evil strategy and all players in $S$ play according to the conservative strategy, they will have to steal
       all their incoming direct trust, thus they will act in a way identical to following the evil strategy as far as
       maxFlow is concerned, thus, by \ref{trustflow}, $Tr_{A \rightarrow T} = maxFlow(A, T) = Tr_{A \rightarrow S}$.
    \end{proof}

    One of the primary aims of this system is to mitigate the danger for sybil attacks whilst maintaining fully decentralized
    autonomy. Let Eve be a possible attacker. Since participation in the network does not require any kind of registration,
    Eve can create any number of players. We will call the set of these players $\mathcal{C}$, or Sybil set. Moreover, Eve
    can invest any amount she chooses, thus she can arbitrarily set the direct trusts of any player $C \in \mathcal{C}$ to
    any player $P \in \mathcal{V}$ ($DTr_{C \rightarrow P}$) and can also steal all incoming direct trust to these players.
    Additionally, we give Eve a set of players $B \in \mathcal{B}$ that she has corrupted (the corrupted set), so she fully
    controls their direct trusts to any player $P \in \mathcal{V}$ ($DTr_{B \rightarrow P}$) and can also steal all incoming
    direct trust to these players. The players $B \in \mathcal{B}$ are considered to be legitimate before the corruption,
    thus they can be directly trusted by any player $P \in \mathcal{V}$ ($DTr_{P \rightarrow B} \geq 0$). However, players
    $C \in \mathcal{C}$ can be trusted only by players $D \in \mathcal{B} \cup \mathcal{C}$ ($DTr_{D \rightarrow C} \geq 0$)
    and not by players $A \in \mathcal{V} \setminus (\mathcal{B} \cup \mathcal{C})$ ($DTr_{A \rightarrow C} = 0$).
    \begin{lemma}[$\forall S \subset \mathcal{V}, v \in S \Rightarrow \forall w \in \mathcal{V}, (v,w) \notin MinCut$] \ \\
       \label{mincutmany}
       Let $S \subset \mathcal{V}$. When calculating $maxFlow(A, S)$, it is impossible to have an edge $(v,w) \in
       MinCut : v \in S$.
    \end{lemma}
    \begin{proof}
       Let $T$ be the auxiliary node ($\forall v \in S, c_{vT} = \infty$). Since $out_A < \infty$, $maxFlow(A, S)
       < \infty$. All edges in the $MinCut$ are saturated, thus $\nexists v \in S : (v,T) \in MinCut$, or else
       $maxFlow(A, S) = \infty$. Suppose that $\exists v \in S, w \in \mathcal{V} : (v,w) \in MinCut$. Then this
       edge must be saturated, that is $x_{vw} = c_{vw} > 0$. However, there exists an alternative flow configuration $X'$
       where $\forall (u,u') \in \mathcal{E} \setminus \{(v,w), (v,T)\}, x_{u,u'}' = x_{u,u'}, x_{vw}' = 0, x_{vT}' = x_{vT}
       + x_{vw}$, which is valid because $\sum\limits_{w \in N^{+}(v)}x_{vw} = \sum\limits_{w \in N^{+}(v)}x_{vw}' \wedge
       c_{vT} = \infty \Rightarrow x_{vT}' \leq c_{vT}$ and $X'$ is maximum as well because it carries exactly the same flow
       as $X$. Thus $(v,w) \notin MinCut$.
    \end{proof}
    \begin{theorem}[Sybil resilience] \ \\
       \label{sybil}
       Let $\mathcal{B} \cup \mathcal{C} \subset \mathcal{V}$ ($\mathcal{B} \cap \mathcal{C} = \emptyset$) be a collusion of
       players who are controlled by an adversary, Eve. Eve also controls the number of players in the Sybil set
       $\mathcal{C}, |\mathcal{C}|$, but players $C \in \mathcal{C}$ are not directly trusted by players outside the
       collusion, contrary to players $B \in \mathcal{B}$, the corrupted set, who may be directly trusted by any player in
       $\mathcal{V}$. It holds that $Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}} = Tr_{A \rightarrow \mathcal{B}}$.
    \end{theorem}
    \begin{proof}
       Suppose two separate games $\mathcal{G}_1 = (\mathcal{V}_1,\mathcal{E}_1), \mathcal{G}_2 = (\mathcal{V}_2,
       \mathcal{E}_2)$ with $(\mathcal{B} \subset \mathcal{V(G)}_1 \wedge \mathcal{B} \subset \mathcal{V(G)}_2) \wedge
       (\mathcal{C} \subset \mathcal{V}_1 \wedge \mathcal{C} \cap \mathcal{V}_2 = \emptyset)$. Let $T_1 \in \mathcal{V}_1$ be
       an auxiliary player such that $\forall D \in \mathcal{B} \cup \mathcal{C}, DTr_{D \rightarrow T_1} = \infty$ and $T_2
       \in \mathcal{V}_2$ be another auxiliary player such that $\forall B \in \mathcal{B}, DTr_{B \rightarrow T_2} =
       \infty$. Suppose also that there exist $|\mathcal{B} \cup \mathcal{C}|$ consecutive turns for the first game and
       $|\mathcal{B}|$ consecutive turns for the second game during which all the colluding players choose actions according
       to the evil strategy. More formally, suppose that $\exists j \in \mathbb{N} : \forall d_1 \in [|\mathcal{B} \cup
       \mathcal{C}|], Player(j+d) \in \mathcal{B} \cup \mathcal{C} \wedge \forall d_1, d_2 \in [|\mathcal{B} \cup
       \mathcal{C}|], d_1 \neq d_2, Player(j + d_1) \neq Player(j + d_2) \wedge \forall d \in [|\mathcal{B} \cup
       \mathcal{C}|], Strategy(Player(j+d)) = Evil \wedge \forall j' \in [j] Player(j') \notin \mathcal{B} \cup \mathcal{C}$
       for the first and likewise for the second game. According to \ref{trustmany}, $Tr_{A \rightarrow \mathcal{B} \cup
       \mathcal{C}} = maxFlow(A, T_1), Tr_{A \rightarrow \mathcal{B}} = maxFlow(A, T_2)$. From lemma \ref{mincutmany}, we
       know that $\forall (v,w) \in MinCut, v \notin \mathcal{B} \cup \mathcal{C}$ and thus $e \in MinCut_1 \Rightarrow e \in
       \mathcal{E}_2 \wedge e \in MinCut_2 \Rightarrow e \in \mathcal{E}_1 \wedge \forall e \in MinCut_1 \cup MinCut_2,
       c_1(e) = c_2(e)$. Thus the flow $X_1$ resulting from $maxFlow(A, T_1)$ can be used to construct a valid flow of equal
       value for the second case if we set $\forall v \in \mathcal{V}_2 \setminus \mathcal{B}, \forall w \in \mathcal{V}_2,
       x_{vw,2} = x_{vw,1} \wedge \forall v \in \mathcal{B}, x_{vT_2,2} = \sum\limits_{w \in N^{+}(v)}x_{vw,1} \wedge \forall
       v,w \in \mathcal{B} \cup \mathcal{C}, x_{vw,2} = 0$. Likewise, the flow $X_2$ resulting from $maxFlow(A, T_2)$ can be
       used to construct a valid flow of equal value for the first case if we set $\forall v \in \mathcal{V}_1 \setminus
       (\mathcal{B} \cup \mathcal{C}), \forall w \in \mathcal{V}_1, x_{vw,1} = x_{vw,2} \wedge \forall v \in \mathcal{B},
       x_{vT_1,1} = \sum\limits_{w \in N^{+}(v)}x_{vw,2} \wedge \forall v \in \mathcal{C}, \forall w \in \mathcal{V}_1,
       x_{vw,1} = 0$. From these two observations, we deduce that there exists a function, say $F_2(X_1)$, that transforms
       the $MaxFlow_1$ of the first graph into a valid flow for the second graph that has the same amount of flow as
       $MaxFlow_1$ and there also exists a similar function $F_1(X_2)$ that transforms the $MaxFlow_2$ of the second graph
       into a valid flow for the first graph that has the same amount of flow as $MaxFlow_2$. Suppose that $maxFlow_1 <
       maxFlow_2$. Then $F_1(MaxFlow_2) > maxFlow_1$ which is a contradiction. The same contradiction arises if we suppose
       that $maxFlow_1 > maxFlow_2$. We conclude that $maxFlow(A, T_1) = maxFlow(A, T_2) \Rightarrow Tr_{A \rightarrow
       \mathcal{B}} = Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}}$.
    \end{proof}
%       Consider the partition of
%       $\mathcal{V}, \mathcal{P} = \{\mathcal{B} \cup \mathcal{C}, \mathcal{V} \setminus (\mathcal{B} \cup \mathcal{C})\} =
%       \{P_1, P_2\}$. The edges from $P_2$ to $P_1$ will carry a flow $X_P, X_{P'}$ and the edges inside of $P_1$ will carry
%       a flow $X_T, X_{T'}$ from the calculation of $maxFlow(A, T), maxFlow(A, T')$ respectively. $maxFlow(A, T) \leq
%       maxFlow(A, T')$ because the maximal configuration of $X_T$ can be part of a valid configuration of $X_{T'}$ since
%       edges in $\mathcal{B}$ are edges in $\mathcal{B} \cup \mathcal{C}$. Both maxFlows are not infinite, because $out_A <
%       \infty$ and according to \ref{mincutmany} all the edges in both $MinCut$s have their starting point outside
%       $\mathcal{B} \cup \mathcal{C}$. However, then in both cases the minCut is the same, thus $maxFlow(A, T) =
%       maxFlow(A, T')$. MISSING Thus we conclude that $Tr_{A \rightarrow \mathcal{B}} =
%       Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}}$.
    We have proven that controlling $|\mathcal{C}|$ is irrelevant for Eve, thus Sybil attacks are meaningless. \\

    Here we show three naive algorithms for calculating new direct trusts so as to maintain invariable risk when paying
    a trusted party. To prove the correctness of the algorithms, it suffices to prove that $\forall i \in [n] \:
    u_i' \leq x_i$ and that $\sum\limits_{i=1}^{n}u_i' = F - V$ where $F = \sum\limits_{i=1}^{n}x_i$. \\
    \begin{algorithm}[H]
       \label{fcfs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{First-come, first-served trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{fcfsfinit}\\
       \If{$F < V$ \label{fcfsifinputvalid}}{\Return $\bot$}
       $F_{cur} \gets F$ \label{fcfsfcurinit}\\
       \For{$i \gets 1$ to $n$ \label{fcfsforcapinit}}
          {$u_i' \gets x_i$} \label{fcfscapinit}
       $i \gets 1$ \label{fcfsiinit}\\
       \While{$F_{cur} > F - V$ \label{fcfsloop}}
          {$reduce \gets \min{(x_i, F_{cur} - F + V)}$ \\
           $F_{cur} \gets F_{cur} - reduce$ \\
           $u_i' \gets x_i - reduce$ \label{capmod}\\
           $i \gets i + 1$ \label{fcfsiinc}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{fcfsreturn}
    \end{algorithm}
    \begin{proof}[Proof of correctness for algorithm \ref{fcfs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          Let $i \in [n]$. In line~\ref{fcfscapinit} we can see that $u_i' = x_i$ and the only other occurence of $u_i'$
          is in line~\ref{capmod} where it is never increased $(reduce \geq 0)$, thus we see that, when returned,
          $u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          $F_{cur,0} = F$ \\
          If $F_{cur,i} \geq F - V$, then $F_{cur,i+1}$ does not exist because the \emph{while} loop breaks after calculating
          $F_{cur,i}$. \\
          Else $F_{cur,i+1} = F_{cur,i} - \min{(x_{i+1}, F_{cur,i} - F + V)}$. \\
          If for some $i, \min{(x_{i+1}, F_{cur,i} - F + V)} = F_{cur,i} - F + V$, then $F_{cur,i+1} = F - V$, so if
          $F_{cur,i+1}$ exists, then $\forall k < i, F_{cur,k} = F_{cur,k-1} - x_k \Rightarrow F_{cur,i} =
          F - \sum\limits_{k=1}^{i}x_k$ \\
          Furthermore, if $F_{cur,i+1} = F - V$ then $u_{i+1}' = x_{i+1} - F_{cur,i} + F - V =
          x_i - F + \sum\limits_{k=1}^{i-1}x_k + F - V = \sum\limits_{k=1}^{i}x_k - V$, $\forall k \leq i, u_k' = 0$
          and $\forall k > i+1, u_k' = x_k$. \\
          In total, we have $\sum\limits_{k=1}^{n}u_k' = \sum\limits_{k=1}^{i}x_k - V + \sum\limits_{k=i+1}^{n}x_k =
          \sum\limits_{k=1}^{n}x_k - V \Rightarrow \sum\limits_{k=1}^{n}u_k' = F - V$.
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{fcfs}] \ \\
       First we will prove that on line~\ref{fcfsreturn} $i \leq n+1$. Suppose that $i > n+1$ on line~\ref{fcfsreturn}. This
       means that $F_{cur,n}$ exists and $F_{cur,n} = F - \sum\limits_{i=1}^{n}x_i = 0 \leq F - V$ since, according to the
       condition on line~\ref{fcfsifinputvalid}, $F - V \geq 0$. This means however that the \emph{while} loop on
       line~\ref{fcfsloop} will break, thus $F_{cur,n+1}$ cannot exist and $i = n + 1$ on line~\ref{fcfsreturn}, which is a
       contradiction, thus $i \leq n+1$ on line~\ref{fcfsreturn}. Since $i$ is incremented by 1 on every iteration of the
       \emph{while} loop (line~\ref{fcfsiinc}), the complexity of the \emph{while} loop is $O(n)$ in the worst case. The
       complexity of lines~\ref{fcfsifinputvalid} -~\ref{fcfsfcurinit} and~\ref{fcfsiinit} is $O(1)$ and the complexity of
       lines~\ref{fcfsfinit},~\ref{fcfsforcapinit} -~\ref{fcfscapinit} and~\ref{fcfsreturn} is $O(n)$, thus the total
       complexity of algorithm \ref{fcfs} is $O(n)$.
    \end{proof}

    \begin{algorithm}[H]
       \label{abs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Absolute equality trust transfer ($||\Delta_i||_\infty$ minimizer)}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}{\Return $\bot$}
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets x_i$ \label{abscapinit}}
       $reduce \gets {V \over n}$ \\
       $reduction \gets 0$ \\
       $empty \gets 0$ \\
       $i \gets 0$ \label{absiinit} \\
       \While{$reduction < V$ \label{absloop}}
          {\If{$u_i' > 0$ \label{absifcappositive}}{\If{$x_i < reduce$ \label{absifflowlessreduce}}
                {$empty \gets empty + 1$ \label{absemptyincrement} \\
                 \If{$empty < n$ \label{absifemptylessn}}
                    {$reduce \gets reduce + \frac{reduce - x_i}{n - empty}$ \label{absreducemodify}}
                 $reduction \gets reduction + u_i'$ \label{absreductionincrease} \\
                 $u_i' \gets 0$ \label{abscapzero} \\}
           \ElseIf{$x_i \geq reduce$}{$reduction \gets reduction + u_i' - (x_i - reduce)$ \label{absreductionmodify} \\
                 $u_i' \gets x_i - reduce$ \label{abscapreduce}}}
           $i \gets (i + 1) mod \:n$ \label{absiincrement}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{absreturn}
    \end{algorithm}
       \noindent
       We will start by showing some results useful for the following proofs. Let $j$ be the number of iterations of the
       \textbf{while} loop for the rest of the proofs for algorithm \ref{abs} (think of $i$ from line~\ref{absiincrement}
       without the $mod\:n$).\\
       First we will show that $empty \leq n$. $empty$ is only modified on line~\ref{absemptyincrement} where it is
       incremented by 1. This happens only when $u_i' > 0$ (line~\ref{absifcappositive}), which is assigned the value 0 on
       line~\ref{abscapzero}. We can see that the incrementation of $empty$ can happen at most $n$ times because
       $|U'| = n$. Since $empty_0 = 0$, $empty \leq n$ at all times of the execution. \\
       Next we will derive the recursive formulas for the various variables. \\
       $empty_0 = 0$ \\
       $empty_{j+1} = 
          \begin{cases}
             empty_j, & u_{(j+1)\:mod\:n}' = 0 \\
             empty_j+1, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             empty_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduce_0 = \frac{V}{n}$ \\
       $reduce_{j+1} =
          \begin{cases}
             reduce_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduce_j + \frac{reduce_j-x_{(j+1)\:mod\:n}}{n-empty_{j+1}}, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \:
                x_{(j+1) \:mod\:n} < reduce_j \\
             reduce_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduction_0 = 0$ \\
       $reduction_{j+1} =
          \begin{cases}
             reduction_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduction_j + u_{(j+1)\:mod\:n}', & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             reduction_j + u_{(j+1)\:mod\:n}' - x_{(j+1)\:mod\:n} + reduce_{j+1}, &
                u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\
       In the end, $r = reduce$ is such that $r = \frac{V - \sum\limits_{x \in S}x}{n - |S|}$ where
       $S = \{\text{flows } y \text{ from } s \text{ to } N^{+}(s) \text{ according to } maxFlow : y < r\}$. Also,
       $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}\max{(0,x_i - r)}$. TOPROVE
    \begin{proof}[Proof of correctness for algorithm \ref{abs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          On line~\ref{abscapinit}, $\forall i \in [n] \: u_i' = x_i$. Subsequently $u_i'$ is modified on
          line~\ref{abscapzero}, where it becomes equal to 0 and on line~\ref{abscapreduce}, where it is assigned
          $x_i - reduce$. It holds that $x_i - reduce \leq x_i$ because initially $reduce = \frac{V}{n} \geq 0$ and
          subsequently $reduce$ is modified only on line~\ref{absreducemodify} where it is increased ($n > empty$ because of
          line~\ref{absifemptylessn} and $reduce > x_i$ because of line~\ref{absifflowlessreduce}, thus
          $\frac{reduce - x_i}{n - empty} > 0$). We see that $\forall i \in [n], u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          The variable $reduction$ keeps track of the total reduction that has happened and breaks the \textbf{while} loop
          when $reduction \geq V$. We will first show that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times and
          then we will prove that $reduction = V$ at the end of the execution. Thus we will have proven that
          $\sum\limits_{i=1}^{n}u_i'= \sum\limits_{i=1}^{n}x_i - V = F - V$.
          \begin{itemize}
             \item On line~\ref{abscapinit}, $u_i' = x_i \Rightarrow \sum\limits_{i=1}^{n}(x_i- u_i') = 0$ and
             $reduction = 0$. \\
             On line~\ref{abscapzero}, $u_i'$ is reduced to 0 thus $\sum\limits_{i=1}^{n}(x_i- u_i')$ is increased by $u_i'$.
             Similarly, on line~\ref{absreductionincrease} $reduction$ is increased by $u_i'$, the same as the increase in
             $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             On line~\ref{abscapreduce}, $u_i'$ is reduced by $u_i' - x_i + reduce$ thus $\sum\limits_{i=1}^{n}(x_i- u_i')$
             is increased by $u_i' - x_i + reduce$. On line~\ref{absreductionmodify}, $reduction$ is increased by
             $u_i' - x_i + reduce$, which is equal to the increase in $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             We also have to note that neither $u_i'$ nor $reduction$ is modified in any other way from line~\ref{absloop}
             and on, thus we conclude that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times.
             \item Suppose that $reduction_j > V$ on the line~\ref{absreturn}. Since $reduction_j$ exists, $reduction_{j-1} < V$.
             If $x_{j \: mod \: n} < reduce_{j-1}$ then $reduction_j = reduction_{j-1} + u_{j \: mod \:n}'$.
             Since $reduction_j > V$, $u_{j \: mod \:n}' > V - reduction_{j-1}$. TOCOMPLETE\\
             
          \end{itemize}
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{abs}] \ \\
       In the worst case scenario, each time we iterate over all capacities only the last non-zero capacity will become zero
       and every non-zero capacity must be recalculated. This means that every $n$ steps exactly 1 capacity becomes zero
       and eventually all capacities (maybe except for one) become zero. Thus we need $O(n^2)$ steps in the worst case.
    \end{proof}
    A variation of this algorithm using a Fibonacci heap with complexity $O(n)$ can be created, but that is part of 
    further research.
    \begin{proof}[Proof that algorithm \ref{abs} minimizes the $||\Delta_i||_\infty$ norm] \ \\
       Suppose that $U'$ is the result of an execution of algorithm \ref{abs} that does not minimize the $||\Delta_i||_\infty$
       norm. Suppose that $W$ is a valid solution that minimizes the $||\Delta_i||_\infty$ norm. Let $\delta$ be the minimum
       value of this norm. There exists $i \in [n]$ such that $x_i - w_i = \delta$ and $u_i' < w_i$. Because both $U'$
       and $W$ are valid solutions ($\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}w_i = F - V$), there must exist a set
       $S \subset U'$ such that $\forall u_j' \in S, u_j' > w_j$ TOCOMPLETE.
    \end{proof}

    \begin{algorithm}[H]
       \label{prop}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Proportional equality trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{propfinit} \\
       \If{$F < V$ \label{propifinputvalid}}{\Return $\bot$ \label{propinputinvalid}}
       \For{$i \gets 1$ to $n$ \label{proploop}}
          {$u_i' \gets x_i - \frac{V}{F} x_i$ \label{propcapmodify}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{propreturn}
    \end{algorithm} \ \\
    \begin{proof}[Proof of correctness for algorithm \ref{prop}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          According to line~\ref{propcapmodify}, which is the only line where $u_i'$ is changed,
          $u_i' = x_i - \frac{V}{F}x_i \leq x_i$ since $x_i, V, F > 0$ and $V \leq F$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          With $F = \sum\limits_{i=1}^{n}x_i$, on line~\ref{propreturn} it holds that $\sum\limits_{i=1}^{n}u_i' =
          \sum\limits_{i=1}^{n}(x_i - \frac{V}{F}x_i) = \sum\limits_{i=1}^{n}x_i - \frac{V}{F}\sum\limits_{i=1}^{n}x_i =
          F - V$.
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{prop}] \ \\
       The complexity of lines~\ref{propfinit},~\ref{proploop} -~\ref{propcapmodify} and~\ref{propreturn} is $O(n)$ and the
       complexity of lines~\ref{propifinputvalid} -~\ref{propinputinvalid} is $O(1)$, thus the total complexity of algorithm
       \ref{prop} is $O(n)$.
    \end{proof}

    Naive algorithms result in $u_i' \leq x_i$, thus according to \ref{invariability}, $||\delta_i||_1$ is invariable for
    any of the possible solutions $U'$, which is not necessarily the minimum (usually it will be the maximum). The following
    algorithms concentrate on minimizing two $\delta_i$ norms, $||\delta_i||_\infty$ and $||\delta_i||_1$. \\
    \begin{algorithm}[H]
       \label{dinf}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{BinSearch}{BinSearch}
       \Input{$X = \{x_i\}$ flows, $n = |N^{+}(s)|$, $V$ value, $\epsilon_1$, $\epsilon_2$}
       \Output{$u_i'$ capacities}
       \caption{$||\delta_i||_\infty$ minimizer}
       \If{$\epsilon_1 < 0 \vee \epsilon_2 < 0$ \label{dinfifepsilonsvalid}}
          {\Return $\bot$ \label{dinfepsilonsinvalid}}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \label{dinffinit} \\
       \If{$F < V$ \label{dinfifvvalid}}
          {\Return $\bot$ \label{dinfvinvalid}}
       $\delta_{max} \gets \max\limits_{i \in [n]}\{u_i\}$ \label{dinfdeltainit} \\
       $\delta^* \gets$ \BinSearch{0,$\delta_{max}$,F-V,n,X,$\epsilon_1$,$\epsilon_2$} \label{dinfcallbs} \\
       \For{$i \gets 1$ to $n$ \label{dinfforcap}}
          {$u_i' \gets \max{(u_i - \delta^*, 0)}$ \label{dinfcapset}}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$ \label{dinfreturn}
    \end{algorithm}
    Since trust should be considered as a continuous unit and binary search dissects the possible interval for the solution
    on each recursive call, inclusion of the $\epsilon$-parameters in \texttt{BinSearch} is necessary for the algorithm to
    complete in a finite number of steps. \\
    \begin{algorithm}[H]
       \label{binsearch}
       \SetKwFunction{BinSearch}{BinSearch}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$bot$, $top$, $F'$, $n$, $X$, $\epsilon_1$, $\epsilon_2$}
       \Output{$\delta^*$}
       \caption*{\textbf{function} \texttt{BinSearch} }
       \If{$bot = top$ \label{bsifboteqtop}}{\Return $bot$ \label{bsretbot}}
       \Else{
          \For{$i \gets 1$ to $n$ \label{bsforcapset}}
              {$u_i' \gets \max{(0,u_i - \frac{top + bot}{2})}$ \label{bscapset}}
          \If{$maxFlow < F' - \epsilon_1$ \label{bsiflow}}
	     {\Return \BinSearch{$bot$, $\frac{top+bot}{2}$,$F'$,$n$,$X$,$\epsilon_1$,$\epsilon_2$} \label{bsreclow}}
          \ElseIf{$maxFlow > F' + \epsilon_2$ \label{bsifhigh}}
	     {\Return \BinSearch{$\frac{top+bot}{2}$, $top$,$F'$,$n$,$X$.$\epsilon_1$,$\epsilon_2$} \label{bsrechigh}}
          \Else
             {\Return $\frac{top + bot}{2}$\label{bsretmid}}
       }
    \end{algorithm}
    \begin{proof}[Proof that $maxFlow(\delta)$ is strictly decreasing for $\delta: maxflow(\delta) < F$] \ \\
       Let $maxFlow(\delta)$ be the $maxFlow$ with $\forall i \in [n], u_i' = max(0, u_i - \delta)$.
       We will prove that the function $maxFlow(\delta)$ is strictly decreasing for all $\delta \leq \max\limits_{i \in
       [n]}\{u_i\}$ such that $maxFlow(\delta) < F$. \\
       Supppose that $\exists \delta_1, \delta_2 : \delta_1 < \delta_2 \wedge maxFlow(\delta_1) \leq maxFlow(\delta_2) < F$.
       We will work with configurations of $x_{i,j}'$ such that $x_{i,j}' \leq x_i, j \in \{1,2\}$. \\
       Let $S_j = \{i \in N^{+}(s) : i \in MinCut_j\}$. It holds that $S_1 \neq \emptyset$ because otherwise $MinCut_1 =
       MinCut_{\delta = 0}$ which is a contradiction because then $maxFlow(\delta_1) = F$. Moreover, it holds that
       $S_1 \subseteq S_2$, since $\forall u_{i,2}' > 0,u_{i,2}' < u_{i,1}'$. Every node in the $MinCut_j$ is saturated, thus
       $\forall i \in S_1, x_{i,j}' = u_{i,j}'$. Thus $\sum\limits_{i \in S_1} x_{i,2} < \sum\limits_{i \in S_1}x_{i,1}$ and,
       since $maxFlow(\delta_1) \leq maxFlow(\delta_2)$, we conclude that for the same configurations,
       $\sum\limits_{i \in N^{+}(s) \setminus S_1} x_{i,2} > \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}$.
       However, since $x_{i,j}' \leq x_i, j \in \{1,2\}$, the configuration
       $[x_{i,1}'' = x_{i,2}', i \in N^{+}(s) \setminus S_1], [x_{i,1}'' = x_{i,1}', i \in S_1]$ is valid for
       $\delta = \delta_1$ and then $\sum\limits_{i \in S_1}x_{i,1}'' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}'' =
       \sum\limits_{i \in S_1}x_{i,1}' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,2}' > maxFlow(\delta_1)$,
       contradiction. Thus $maxFlow(\delta)$ is strictly decreasing.
    \end{proof}
       We can see that if $V > 0, F' = F - V < F$ thus if $\delta \in (0, \max\limits_{i \in [n]}\{u_i\}]:
       maxFlow(\delta)= F' \Rightarrow \delta = \min||\delta_i||_\infty : maxFlow(||\delta_i||_\infty) = F'$.
       
    \begin{proof}[Proof of correctness for function \ref{binsearch}] \ \\
       Supposing that $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$, or equivalently
       $maxFlow(top) \leq F' - \epsilon_1 \wedge maxFlow(bot) \geq F' + \epsilon_2$, we will prove that
       $maxFlow(\delta^*) \in [F' - \epsilon_1, F' + \epsilon_2]$. \\
       First of all, we should note that if an invocation of \texttt{BinSearch} returns without calling \texttt{BinSearch}
       again (line~\ref{bsretbot} or~\ref{bsretmid}), its return value will be equal to the return value of the initial
       invocation of \texttt{BinSearch}, as we can see on lines~\ref{bsreclow} and~\ref{bsrechigh}, where the return value of
       the invoked \texttt{BinSearch} is returned without any modification. The case where \texttt{BinSearch} is called again
       is analyzed next:
       \begin{itemize}
          \item If $maxFlow(\frac{top+bot}{2}) < F' - \epsilon_1 < F'$ (line~\ref{bsiflow}) then, since $maxFlow(\delta)$ is
          strictly decreasing, $\delta^* \in [bot,\frac{top+bot}{2})$. As we see on line~\ref{bsreclow}, the interval
          $(\frac{top+bot}{2}, top]$ is discarded when the next \texttt{BinSearch} is called. Since $F' + \epsilon_2 \leq
          maxFlow(bot)$, we have $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(\frac{top+bot}{2}), maxFlow(bot)]$ and
          the length of the available interval is divided by 2.
          \item Similarly, if $maxFlow(\frac{top+bot}{2}) > F' + \epsilon_2 > F'$ (line~\ref{bsifhigh}) then $\delta^* \in
          (\frac{top+bot}{2}, top]$. According to line~\ref{bsrechigh}, the interval $[bot, \frac{top+bot}{2})$ is discarded
          when the next \texttt{BinSearch} is called. Since $F'- \epsilon_1 \geq maxFlow(top)$, we have $[F' - \epsilon_1, F'
          + \epsilon_2] \subset (maxFlow(top),$ $maxFlow(\frac{top+bot}{2})]$ and the length of the available interval is
          divided by 2.
       \end{itemize}
       As we saw, $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$ in every recursive call and
       $top - bot$ is divided by 2 in every call. From topology we know that $A \subset B \Rightarrow |A| < |B|$, so the
       recursive calls cannot continue infinitely. $|[F' - \epsilon_1, F' + \epsilon_2]| = \epsilon_1 + \epsilon_2$. Let
       $bot_0, top_0$ the input values given to the initial invocation of \texttt{BinSearch}, $bot_j,top_j$ the input
       values given to the $j$-th recursive call of \texttt{BinSearch} and $len_j =|[bot_j, top_j]| = top_j - bot_j$. We have
       $\forall j > 0, len_j = top_j - bot_j = \frac{top_{j-1} - bot_{j-1}}{2} \Rightarrow \forall j >0, len_j =
       \frac{top_0 - bot_0}{2^j}$. We understand that in the worst case $len_j = \epsilon_1 + \epsilon_2 \Rightarrow
       2^j = \frac{top_0-bot_0}{\epsilon_1 + \epsilon_2} \Rightarrow j = \log_2(\frac{top_0-bot_0}{\epsilon_1+\epsilon_2})$.
       Also, as we saw earlier, $\delta^*$ is always in the available interval, thus $maxFlow(\delta^*) \in [F' - \epsilon_1,
       F' + \epsilon_2]$.
%       We will show that the output of \ref{binsearch}, $\delta \in [bot_0, top_0]$, is such that
%\subset [0, \max\limits_{i \in [n]}\{u_i\}]
%       $\sum\limits_{i=1}^{n}\max{(u_i - \delta, 0)} = F' = F - V$. \\
%       We can easily see that $\delta_1 < \delta_2 \Rightarrow \sum\limits_{i=1}^{n}\max{(u_i - \delta_1, 0)} >
%       \sum\limits_{i=1}^{n}\max{(u_i - \delta_2, 0)} \Rightarrow maxFlow_{\delta_1} \geq maxFlow_{\delta_2} (1)$.
%       The recursive function starts backtracking either on line 11, where $maxFlow = F'$, or on line 2 where $bot_j=top_j$.
%       In the latter case, it is $round(\frac{bot_{j-1}+top_{j-1}}{2}) = bot_j$ and we have either $bot_{j-1} = bot_j$ or
%       $top_{j-1} = top_j$.
%       \begin{itemize}
%          \item $bot_{j-1} = bot_j \Rightarrow round(\frac{bot_j + top_{j-1}}{2}) = bot_j \xRightarrow{top_{j-1} > bot_j}
%          bot_j < \frac{bot_j + top_{j-1}}{2} < bot_j + 0.5 \Rightarrow bot_j < top_{j-1} < bot_j + 1$ impossible.
%          \item $top_{j-1} = top_j \Rightarrow round(\frac{bot_{j-1} + top_j}{2}) = top_j \xRightarrow{top_j > bot_{j-1}}
%          top_j - 0.5 \leq \frac{bot_{j-1} + top_j}{2} < top_j \Rightarrow top_j - 1 \leq bot_{j-1} < top_j
%          \Rightarrow bot_{j-1} = top_j - 1$. In this case $round(\frac{bot_{j-1} + top_{j-1}}{2}) =
%          round(\frac{top_j - 1 + top_j}{2}) = round(top_j - 0.5) = top_j \Rightarrow
%          maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} = maxFlow_{bot_j}$. Since $bot_j$ exists, \\
%          $maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} \neq F'$.
%       \end{itemize}
%$bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j$ or $bot_{j-1} = bot_j \wedge
%       top_{j-1} = top_j + 1$.
%       \begin{itemize}
%          \item If $bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j, maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}} >F',
%          (1) \Rightarrow maxFlow_{bot_j} \leq maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}}$
%       \end{itemize}
%$\forall \delta': 0 \leq \delta' < bot_j, maxFlow > F'$ because $\exists i \in [0,j):bot_i \leq \delta' \leq top_i$
    \end{proof}
    \begin{proof}[Complexity of function \ref{binsearch}] \ \\
       Lines~\ref{bsifboteqtop} -~\ref{bsretbot} have complexity $O(1)$, lines~\ref{bsforcapset} -~\ref{bscapset} have
       complexity $O(n)$, lines~\ref{bsiflow} -~\ref{bsretmid} have complexity $O(maxFlow) + O(BinSearch)$. As we saw in the
       proof of correctness for function \ref{binsearch}, we need at most $\log_2(\frac{top - bot}{\epsilon_1 +
       \epsilon_2})$ recursive calls of \texttt{BinSearch}. Thus the function \ref{binsearch} has worst-case complexity
       $O((maxFlow + n)\log_2(\frac{top - bot}{\epsilon_1 + \epsilon_2}))$.
    \end{proof}
    \begin{proof}[Proof of correctness for algorithm \ref{dinf}] \ \\
       We will show that $maxFlow \in [F - V - \epsilon_1, F - V + \epsilon_2]$, with $u_i'$ decided by algorithm
       \ref{dinf}. \\
       Obviously $maxFlow(0) = F, maxFlow(\max\limits_{i \in [n]}\{u_i\}) = 0$, thus $\delta^* \in
       \max\limits_{i \in [n]}\{u_i\}$. According to the proof of correctness for function \ref{binsearch},
       we can directly see that $maxFlow(\delta^*) \in [F - V - \epsilon_1, F - V + \epsilon_2]$, given that
       $\epsilon_1, \epsilon_2$ are chosen so that $F - V - \epsilon_1 \geq 0, F - V + \epsilon_2 \leq F$, so as to satisfy
       the condition $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$.
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{dinf}] \ \\
       The complexity of lines~\ref{dinfifepsilonsvalid} -~\ref{dinfepsilonsinvalid} and~\ref{dinfifvvalid}
       -~\ref{dinfvinvalid} is $O(1)$, the complexity of lines~\ref{dinffinit},~\ref{dinfdeltainit},~\ref{dinfforcap}
       -~\ref{dinfcapset} and~\ref{dinfreturn} is $O(n)$ and the complexity of line~\ref{dinfcallbs} is $O(BinSearch) =
       O((maxFlow + n) \log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$, thus the total complexity of algorithm
       \ref{dinf} is $O((maxFlow + n)\log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$.
    \end{proof}

    However, we need to minimize $\sum\limits_{i=1}^{n}(u_i-u_i') = ||\delta_i||_1$.

  \section{Related Work}

  \section{Further Research}

  While our trust network can form a basis for risk-invariant transactions in
  the anonymous and decentralized setting, more research is required to achieve
  other desirable properties. Some directions for future research are outlined
  below.

  \subsection{Zero knowledge}

  Our network evaluates indirect trust by computing the max flow in the graph
  of lines-of-credit. In order to do that, complete information about the
  network is required. However, disclosing the network topology may be
  undesirable, as it subverts the identity of the participants even when
  participants are treated pseudonymously, as deanonymization techniques can be
  used. To avoid such issues, exploring the ability to calculate flows in a
  zero knowledge fashion may be desirable. However, performing network queries
  in zero knowledge may allow an adversary to extract topological information.
  More research is required to establish how flows can be calculated
  effectively in zero knowledge and what bounds exist in regards to information
  revealed in such fashion.

  \begin{thebibliography}{20}
     \bibitem{ddosattacks}
     \href{http://www.cisco.com/c/en/us/about/press/internet-protocol-journal/back-issues/table-contents-30/dos-attacks.html}
           {Distributed Denial of Service Attacks - The Internet Protocol Journal - Volume 7, Number 4}
     \bibitem{ebayfees}
     \href{http://pages.ebay.com/help/sell/fees.html}{Standard ebay selling fees}
     \bibitem{ebayguarantee}
     \href{http://pages.ebay.com/ebay-money-back-guarantee/questions.html}{ebay money back guarantees}
     \bibitem{openbazaar}
     \href{https://blog.openbazaar.org/what-is-openbazaar/}{What is OpenBazaar}
     \bibitem{multisigfraud}
     \href{https://blog.openbazaar.org/can-bitcoin-and-multisig-reduce-identity-theft-and-fraud/}{Can bitcoin and multisig
     reduce identity theft and fraud?}
     \bibitem{bitcoin}
     \href{https://bitcoin.org/bitcoin.pdf}{Nakamoto, Satoshi (2008). Bitcoin: A Peer-to-Peer Electronic Cash System}
     \bibitem{toposort}
     Kahn, Arthur B. (1962), "Topological sorting of large networks", Communications of the ACM
     \bibitem{clrs}
     Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2009) [1990]. Introduction to Algorithms
     (3rd ed.). MIT Press and McGraw-Hill.
     \bibitem{dionyziz}
     \href{https://dionyziz.com/pseudonymous-trust-2.pdf}{Zindros, Dionysis S. (2015). Trust in decentralized anonymous
     marketplaces}
     \bibitem{multisig}
     \href{https://bitcoinmagazine.com/articles/multisig-future-bitcoin-1394686504}{Bitcoin Magazine (2014). Bitcoin Multisig
     Wallet: The Future of Bitcoin}
     \bibitem{loc}
     \href{https://gist.github.com/drwasho/2c40b91e169f55988618#part-3-web-of-credit}{Washington, Sanchez (2016). Lines of
     Credit}
  \end{thebibliography}

\end{document}
